/*
 * E57Foundation.h - public header of E57 format reference implementation.
 *
 * Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#ifndef E57FOUNDATION_H_INCLUDED
#define E57FOUNDATION_H_INCLUDED

// Define the following symbol to enable heap corruption and memory leakage debugging:
//#define E57_DEBUG_MEMORY 1
#if E57_DEBUG_MEMORY
#  define _CRTDBG_MAP_ALLOC
#  include <stdlib.h>
#  include <crtdbg.h>
#endif

#include <vector>
#include <string>
#include <iostream>
#include "stdint.h"     // for uint8_t, uint16_t, uint32_t, etc...

namespace e57 {

// Shorthand for unicode string
typedef std::string ustring;

enum NodeType {
    E57_STRUCTURE         = 1,
    E57_VECTOR            = 2,
    E57_COMPRESSED_VECTOR = 3,
    E57_INTEGER           = 4,
    E57_SCALED_INTEGER    = 5,
    E57_FLOAT             = 6,
    E57_STRING            = 7,
    E57_BLOB              = 8
};

enum FloatPrecision {
    E57_SINGLE = 0,
    E57_DOUBLE = 1
};

// The URI of E57 v1.0 standard XML namespace
// Used to identify the standard field names and the grammar that relates them.
// Will typically be associated with the default namespace in an E57 file.
// Field names in the default namespace have no prefix (e.g. "cartesianX" as opposed to "las:edgeOfFlightLine").
#define E57_V1_0_URI "http://www.astm.org/COMMIT/E57/2010-e57-v0.5" //??? change to v1.0 before final release

// The URI of the LAS extension.    ??? should not be in E57Foundation.h, should be in separate file with names of fields
// Used to identify the extended field names for encoding data from LAS files (LAS versions 1.0 to 1.3).
// By convention, will typically be used with prefix "las".  ???"las13"?
#define LAS_V1_0_URI "http://www.astm.org/COMMIT/E57/2010-las-v0.5" //??? change to v1.0 before final release

// Forward references to classes in this header
class Node;
class StructureNode;
class VectorNode;
class SourceDestBuffer;
class CompressedVectorReader;
class CompressedVectorWriter;
class CompressedVectorNode;
class IntegerNode;
class ScaledIntegerNode;
class FloatNode;
class StringNode;
class BlobNode;
class ImageFile;

//???doc
//??? Can define operator-> that will make implementation more readable
// Internal implementation files should include e57FoundationImpl.h first which defines symbol E57_INTERNAL_IMPLEMENTATION_ENABLE.
// Normal API users should not define this symbol.
#ifdef E57_INTERNAL_IMPLEMENTATION_ENABLE
#  define E57_OBJECT_IMPLEMENTATION(T)                              \
public:                                                             \
    std::tr1::shared_ptr<T##Impl> impl() const {return(impl_);};    \
protected:                                                          \
    std::tr1::shared_ptr<T##Impl> impl_;
#else
#  define E57_OBJECT_IMPLEMENTATION(T)                              \
protected:                                                          \
    std::tr1::shared_ptr<T##Impl> impl_;
#endif

#if 1 //$$$
// Forward references to implementation in other headers (so don't have to include E57FoundationImpl.h)
//??? test all needed?
class NodeImpl;
class StructureNodeImpl;
class VectorNodeImpl;
class SourceDestBufferImpl;
class CompressedVectorReaderImpl;
class CompressedVectorWriterImpl;
class CompressedVectorNodeImpl;
class IntegerNodeImpl;
class ScaledIntegerNodeImpl;
class FloatNodeImpl;
class StringNodeImpl;
class BlobNodeImpl;
class ImageFileImpl;
class E57XmlParser;  //??? needed?
class Encoder;  //??? needed?
class Decoder;  //??? needed?
template <typename RegisterT> class BitpackIntegerEncoder;  //??? needed?
#endif

class Node {
public:
    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
#ifdef E57_INTERNAL_IMPLEMENTATION_ENABLE
    explicit    Node(std::tr1::shared_ptr<NodeImpl>);  // internal use only
#endif
private:   //=================
                Node();                 // Not defined, can't default construct Node, see StructureNode(), IntegerNode()...

protected: //=================
    friend NodeImpl;

    E57_OBJECT_IMPLEMENTATION(Node)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class StructureNode {
public:
                StructureNode(ImageFile imf);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    int64_t     childCount();
    bool        isDefined(const ustring& pathName);
    Node        get(int64_t index);
    Node        get(const ustring& pathName);
    void        set(const ustring& pathName, Node n, bool autoPathCreate = false);
    void        append(Node n);

    // Up/Down cast conversion //???split into two comments
                operator Node();
    explicit    StructureNode(Node& n);

    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    friend ImageFile;

                StructureNode(std::tr1::shared_ptr<StructureNodeImpl> ni);    // internal use only
                StructureNode(std::tr1::weak_ptr<ImageFileImpl> fileParent);  // internal use only

    E57_OBJECT_IMPLEMENTATION(StructureNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};


class VectorNode {
public:
    explicit    VectorNode(ImageFile imf, bool allowHeteroChildren = false);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    bool        allowHeteroChildren();

    int64_t     childCount();
    bool        isDefined(const ustring& pathName);
    Node        get(int64_t index);  //??? allow Node get(const ustring& pathName); and set...
    void        append(Node n);

    // Up/Down cast conversion
                operator Node();
    explicit    VectorNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    Node        get(const ustring& pathName);           // not available ???allow if numeric string
    void        set(const ustring& pathName, Node n, bool autoPathCreate = false);  // not available ???allow if numeric string

                VectorNode(std::tr1::shared_ptr<VectorNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(VectorNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class SourceDestBuffer {
public:
    SourceDestBuffer(ImageFile imf, ustring pathName, int8_t* b,   unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(int8_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, uint8_t* b,  unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(uint8_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, int16_t* b,  unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(int16_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, uint16_t* b, unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(uint16_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, int32_t* b,  unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(int32_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, uint32_t* b, unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(uint32_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, int64_t* b,  unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(int64_t));
    SourceDestBuffer(ImageFile imf, ustring pathName, bool* b,     unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(bool));
    SourceDestBuffer(ImageFile imf, ustring pathName, float* b,    unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(float));
    SourceDestBuffer(ImageFile imf, ustring pathName, double* b,   unsigned capacity, bool doConversion = false, bool doScaling = false, 
                     size_t stride = sizeof(double));
    SourceDestBuffer(ImageFile imf, ustring pathName, std::vector<ustring>* b);

    ustring         pathName();
    enum MemoryRep  elementType();
    unsigned        capacity();
    bool            doConversion();
    bool            doScaling();
    size_t          stride();

    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================

    E57_OBJECT_IMPLEMENTATION(SourceDestBuffer)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class CompressedVectorReader {
public:
    unsigned    read();
    unsigned    read(std::vector<SourceDestBuffer>& dbufs);
    void        seek(uint64_t recordNumber); //$$$ not implemented yet
    void        close();

    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    //??? no default ctor, copy
    friend CompressedVectorNode;

                CompressedVectorReader(std::tr1::shared_ptr<CompressedVectorReaderImpl> ni);

    E57_OBJECT_IMPLEMENTATION(CompressedVectorReader)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class CompressedVectorWriter {
public:
    void        write(unsigned requestedElementCount);
    void        write(std::vector<SourceDestBuffer>& sbufs, unsigned requestedElementCount);
    void        close();

    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    //??? no default ctor, copy
    friend CompressedVectorNode;

                CompressedVectorWriter(std::tr1::shared_ptr<CompressedVectorWriterImpl> ni);

    E57_OBJECT_IMPLEMENTATION(CompressedVectorWriter)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class CompressedVectorNode {
public:
    explicit    CompressedVectorNode(ImageFile imf, Node prototype, Node codecs);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    int64_t     childCount();
    bool        isDefined(const ustring& pathName); //??? needed?
    Node        prototype();

    // Iterators
    CompressedVectorWriter writer(std::vector<SourceDestBuffer>& sbufs);  //??? totalRecordCount?
    CompressedVectorReader reader(std::vector<SourceDestBuffer>& dbufs);  //??? totalRecordCount?

    // Up/Down cast conversion
                operator Node();
    explicit    CompressedVectorNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    friend E57XmlParser;

                CompressedVectorNode(std::tr1::shared_ptr<CompressedVectorNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(CompressedVectorNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class IntegerNode {
public:
    explicit    IntegerNode(ImageFile imf, int64_t  value, int64_t  minimum = INT64_MIN, int64_t  maximum = INT64_MAX);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    int64_t     value();
    int64_t     minimum();
    int64_t     maximum();

    // Up/Down cast conversion
                operator Node();
    explicit    IntegerNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================

                IntegerNode(std::tr1::shared_ptr<IntegerNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(IntegerNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class ScaledIntegerNode {
public:
    explicit    ScaledIntegerNode(ImageFile imf, int64_t  value, int64_t  minimum = INT64_MIN, int64_t  maximum = INT64_MAX,  
                                  double scale = 1.0, double offset = 0.0);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    int64_t     rawValue();
    double      scaledValue();
    int64_t     minimum();
    int64_t     maximum();
    double      scale();
    double      offset();

    // Up/Down cast conversion
                operator Node();
    explicit    ScaledIntegerNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================

                ScaledIntegerNode(std::tr1::shared_ptr<ScaledIntegerNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(ScaledIntegerNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class FloatNode {
public:
    explicit    FloatNode(ImageFile imf, float value, FloatPrecision precision = E57_SINGLE,
                          double minimum = DOUBLE_MIN, double  maximum = DOUBLE_MAX);
    explicit    FloatNode(ImageFile imf, double value, FloatPrecision precision = E57_DOUBLE,
                          double minimum = DOUBLE_MIN, double  maximum = DOUBLE_MAX);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    double      value();
    FloatPrecision precision();
    double      minimum();
    double      maximum();

    // Up/Down cast conversion
                operator Node();
    explicit    FloatNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================

                FloatNode(std::tr1::shared_ptr<FloatNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(FloatNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class StringNode {
public:
    explicit    StringNode(ImageFile imf, ustring value = ""); //??? explicit?, need default ""?

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    ustring     value();

    // Up/Down cast conversion
                operator Node();
    explicit    StringNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    friend StringNodeImpl;
                StringNode(std::tr1::shared_ptr<StringNodeImpl> ni);  // internal use only

    E57_OBJECT_IMPLEMENTATION(StringNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class BlobNode {
public:
    explicit    BlobNode(ImageFile imf, uint64_t byteCount);

    NodeType    type();
    bool        isRoot();
    Node        parent();
    ustring     pathName();
    ustring     elementName();

    int64_t     byteCount();
    void        read(uint8_t* buf, uint64_t start, size_t byteCount);
    void        write(uint8_t* buf, uint64_t start, size_t byteCount);

    // Up/Down cast conversion
                operator Node();
    explicit    BlobNode(Node& n);
            
    // Diagnostic functions:
    void        dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    friend E57XmlParser;

                BlobNode(std::tr1::shared_ptr<BlobNodeImpl> ni);       // internal use only

                // Internal use only, create blob already in a file
                BlobNode(ImageFile imf, uint64_t fileOffset, uint64_t length);

    E57_OBJECT_IMPLEMENTATION(BlobNode)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

class ImageFile {
public:
                    ImageFile(const ustring& fname, const ustring& mode, const ustring& configuration = "");
    StructureNode   root();
    void            close();
    void            cancel();

    // Manipulate registered extensions in the file
    void            extensionsAdd(const ustring& prefix, const ustring& uri);
    bool            extensionsLookupPrefix(const ustring& prefix, ustring& uri);
    bool            extensionsLookupUri(const ustring& uri, ustring& prefix);
    int             extensionsCount();
    ustring         extensionsPrefix(int index);
    ustring         extensionsUri(int index);

    // Field name functions:
    bool            elementNameIsExtended(const ustring& elementName);
    bool            elementNameIsWellFormed(const ustring& elementName, bool allowNumber = true);
    void            elementNameParse(const ustring& elementName, ustring& prefix, ustring& localPart);

    // Diagnostic functions:
    void            dump(int indent = 0, std::ostream& os = std::cout);

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
protected: //=================
    //??? copy, default ctor, assign

    ImageFile(std::tr1::shared_ptr<ImageFileImpl> imfi);  // internal use only

    E57_OBJECT_IMPLEMENTATION(ImageFile)  // Internal implementation details, not part of API, must be last in object
//! \endcond
};

enum ErrorCode {
    E57_SUCCESS                                 = 0,
    E57_ERROR_BAD_CV_HEADER                     = 1,
    E57_ERROR_BAD_CV_PACKET                     = 2,
    E57_ERROR_CHILD_INDEX_OUT_OF_BOUNDS         = 3,
    E57_ERROR_SET_TWICE                         = 4,
    E57_ERROR_HOMOGENEOUS_VIOLATION             = 5,
    E57_ERROR_VALUE_NOT_REPRESENTABLE           = 6,
    E57_ERROR_SCALED_VALUE_NOT_REPRESENTABLE    = 7,
    E57_ERROR_REAL64_TOO_LARGE                  = 8,
    E57_ERROR_EXPECTING_NUMERIC                 = 9,
    E57_ERROR_EXPECTING_USTRING                 = 10,
    E57_ERROR_INTERNAL                          = 11,
    E57_ERROR_BAD_XML_FORMAT                    = 12,
    E57_ERROR_XML_PARSER                        = 13,
    E57_ERROR_BAD_API_ARGUMENT                  = 14,
    E57_ERROR_FILE_IS_READ_ONLY                 = 15,
    E57_ERROR_CHECKSUM_MISMATCH                 = 16,
    E57_ERROR_OPEN_FAILED                       = 17,
    E57_ERROR_CLOSE_FAILED                      = 18,
    E57_ERROR_READ_FAILED                       = 19,
    E57_ERROR_WRITE_FAILED                      = 20,
    E57_ERROR_LSEEK_FAILED                      = 21,
    E57_ERROR_PATH_UNDEFINED                    = 22,
    E57_ERROR_BAD_BUFFER                        = 23,
    E57_ERROR_NO_BUFFER_FOR_ELEMENT             = 24,
    E57_ERROR_BUFFER_SIZE_MISMATCH              = 25,
    E57_ERROR_BUFFER_DUPLICATE_PATHNAME         = 26,
    E57_ERROR_BAD_FILE_SIGNATURE                = 27,
    E57_ERROR_UNKNOWN_FILE_VERSION              = 28,
    E57_ERROR_BAD_FILE_LENGTH                   = 29,
    E57_ERROR_XML_PARSER_INIT                   = 30,
    E57_ERROR_DUPLICATE_NAMESPACE_PREFIX        = 31,
    E57_ERROR_DUPLICATE_NAMESPACE_URI           = 32,
    E57_ERROR_FILE_NOT_OPEN                     = 33,
    E57_ERROR_BUFFER_NOT_SPECIFIED              = 34,
    E57_ERROR_BAD_PROTOTYPE                     = 35,
    E57_ERROR_VALUE_OUT_OF_BOUNDS               = 36,
    E57_ERROR_CONVERSION_REQUIRED               = 37,
    E57_ERROR_READ_MODE_REQUIRED                = 38,
    E57_ERROR_BAD_ELEMENT_NAME                  = 39,
    E57_ERROR_BAD_PATH_NAME                     = 40,
    E57_ERROR_BAD_NAME_CHAR                     = 41,
    E57_ERROR_UNKNOWN_PREFIX                    = 42,
    E57_ERROR_NOT_IMPLEMENTED                   = 43,
    E57_ERROR_BAD_NODE_TYPECAST                 = 44,
    E57_ERROR_WRITER_NOT_OPEN                   = 45,
    E57_ERROR_READER_NOT_OPEN                   = 46,
};

class E57Exception : public std::exception {
public:
    virtual void        report(char* reportingFileName=NULL, int reportingLineNumber=0, char* reportingFunctionName=NULL, std::ostream& os = std::cout);
    virtual ErrorCode   errorCode();
    virtual ustring     context();
    virtual const char* what();

    // For debugging purposes:
    virtual char*       sourceFileName();
    virtual char*       sourceFunctionName();
    virtual int         sourceLineNumber();

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
    E57Exception(ErrorCode ecode, ustring context,
                 char* srcFileName = NULL, int srcLineNumber = 0, char* srcFunctionName = NULL);

protected: //=================
    //??? copy, default ctor, assign

    ErrorCode   errorCode_;
    ustring     context_;
    char*       sourceFileName_;
    char*       sourceFunctionName_;
    int         sourceLineNumber_;
//! \endcond
};

class E57Utilities {
public:
    // Constructor (does nothing for now)
                E57Utilities(const ustring& configuration = "") {};

    // Get latest version of ASTM standard supported, and library id string
    void        getVersions(int& astmMajor, int& astmMinor, ustring& libraryId);

    // Error code translation
    ustring     errorCodeToString(ErrorCode ecode);

    // Direct read of XML representation in E57 file
    uint64_t    rawXmlLength(const ustring& fname);
    void        rawXmlRead(const ustring& fname, uint8_t* buf, uint64_t start, size_t byteCount);
};

};  // end namespace e57

#endif // E57FOUNDATION_H_INCLUDED
