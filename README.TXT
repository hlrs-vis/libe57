Summary

This document describes the contents of the v0.1 (alpha) distribution of source
code for the E57 Foundation API (application programmer interface).
The distribution is posted in E57Foundation0.1.zip in the E57.04 GoogleGroups
file area:
http://groups.google.com/group/astm-e57-data-interoperability/files?hl=en.
The plan for the reference implementation calls for two APIs: a “simple” API
that allows simplified access to specific areas in an E57 file, and an
“advanced” (or general) API that allows user access to extended areas in an
E57 file.  This distribution contains only the advanced version, not the simple
version.  The advanced API is implemented in C++.



Contents

The E57Foundation0.1.zip file contains the following source files:

DemoRead01.cpp –  read .e57 file from disk and print
DemoWrite01.cpp – example program using API to create .e57 file.
E57Foundation.cpp – public part of API function implementation.
E57Foundation.h – API classes and function declarations (the interface an
    application sees).
E57FoundationImpl.cpp – hidden part of API implementation.
E57FoundationImpl.h – hidden implementation class declarations.
build.bat – batch file to compile source (no Visual Studio project file or
    makefile yet).
foo.e57 – example E57 file.  Generated by DemoWrite01.exe.
gpl-3.0.txt – GNU general public license.  For reference only.  All source
    licensed under LGPL.
lgpl-3.0.txt – GNU lesser general public license (LGPL).
stdint.h – definition of some integer types.  To be replaced by a standard
    file later.


Dependencies

The Microsoft Visual C++ compiler version 15.00.21022.08 (part of Microsoft
Visual Studio 2008) was used to develop the code on a Windows XP platform.
The Visual C++ 2008 Feature Pack was installed for support for ISO TR1 standard
C++ library support.  Xerces-c v3.0.0 was used as the XML parser
(from http://xerces.apache.org/xerces-c/download.cgi).  The batch file assumes
that Xerces is installed in c:\xerces-c-3.0.0\.
<NOTE from roland_schwarz: SVN contains a sligthly mor convenient batch file.>

What you get

The implementation now reads and writes binary CompressedVectors and Blobs.
The numeric values are packed into the file without any empty bits (using the
BitPack codec).  Almost all of the API functions are implemented (see “What
you don’t get” below).  This is a source-only distribution.  Source code for
two example programs (DemoWrite01 and DemoRead01) are included.  The source
is distributed under the GNU LGPL license. The source code is currently about
10,000 lines of C++.  It has only been built on a MS Windows platform.


What you don’t get

- Errors are reported as C++ exception strings.  An exception class with E57
specific fields needs to be implemented.

- Seeking in a random-access fashion to arbitrary records in a CompressedVector
is not implemented.

- Unicode strings stored in a binary section (in a CompressedVector) are not
implemented.

- Source code needs to be split into smaller files for maintenance.

- The checksum stored in the file is not iSCSI CRC as in specification.
However it correctly detects corruption for now.

- Values stored in XML are attributes rather than XML child text required by
the design spec.

- Using get() function to access hierarchy nodes stored within a binary
CompressedVector is not supported (values inside a CompressedVector must be
read to/from SourceDestBuffers as a block rather than individually).

- Extension field names are not validated with the registered extensions in
the file.

- Documentation of API and internal implementation need a lot more work.


What does API use look like?

See DemoWrite01.cpp for example application code.  The hierarchical tree is
constructed by creating nodes and attaching them to other nodes in the tree.
The various node classes are implemented in such a way that you don’t have to
worry about freeing them (they are handles to the real objects).  For primitive
type nodes (i.e. the non-container nodes: IntegerNode, ScaledIntegerNode,
FloatNode, StringNode, BlobNode), you usually don’t need to save the node
handle in a C++ variable – you can just add the node to a StructureNode or
VectorNode.  However handles of the container nodes (StructureNode, VectorNode,
CompressedVectorNode) usually do need to be saved, so that other nodes can be
added to them later in the program.  Once the hierarchical tree is built in
memory, the file is closed and the XML is written to the disk.
CompressedVectorNodes are written to by assembling a list of buffers,
each associated with a field name.  The buffer list is then used to create a
writer object, which can be commanded to send the next block of data, after
the buffers have been refilled with new data.
