//////////////////////////////////////////////////////////////////////////
//
//  E57Simple.cpp - private implementation header of E57 format reference implementation.
//
//	Copyright (c) 2010 Stan Coleby (scoleby@intelisum.com)
//	All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
// 
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//	The Boost license Vestion 1.0 - August 17th, 2003 is discussed in
//	http://www.boost.org/users/license.html.
//
//  This source code is only intended as a supplement to promote the
//	ASTM E57.04 3D Imaging System File Format standard for interoperability
//	of Lidar Data.  See http://www.libe57.org.
//
//////////////////////////////////////////////////////////////////////////
//
//	New E57Simple.cpp
//	V1		May 18, 2010	Stan Coleby		scoleby@intelisum.com
//
//////////////////////////////////////////////////////////////////////////
/*================*/ /*!
@mainpage

@section main_Introduction Introduction
This browser-based document describes the E57 Simple API (Application Programmer Interface) version 0.51, which is a collection of functions that help a C++ programmer wrap the E57 Foundation API.

@section main_Read_example Reading using the E57 Simple API
An example of a typical use of this interface would be as follows:
<tt><PRE>
	try
	{
// Create a ReaderImpl
		_bstr_t bsFile = sFile;			//converts Unicode to UTF-8
		e57::Reader		eReader( (char*) bsFile);

// Read the root
		e57::E57Root	root;
		eReader.GetE57Root( root);		

//Get the number of scan images available
		int data3DCount = eReader.GetData3DCount();

//selecting the first scan
		int scanIndex = 0;

//Read the scan 0 header.
		e57::Data3D		header;
		eReader.ReadData3D( scanIndex, header);

// ...	access all the header information like
		char* scanGuid = header.guid.c_str();

//Get the Size of the Scan
		int64_t nColumn = 0;	
		int64_t nRow = 0;
		int64_t nPoint = 0;	//Number of points
		int64_t nGroup = 0;	//Number of groups
		eReader.GetData3DSizes( scanIndex, nRow, nColumn, nPoints, nGroups);

//Set up buffers
		double* x = new double[nPoint];
		double* y = new double[nPoint];
		double* z = new double[nPoint];
		CompressedVectorReader dataReader = eReader.SetUpData3DPointsData( scanIndex, nPoint, NULL, x, y, z);

//Read the point data
		dataReader.read();

// ... access the data

//Close and clean up
		dataReader.close();
		eReaer.Close();	

		delete x;
		delete y;
		delete z;

//Catch the errors
	} catch(E57Exception& ex) {
		ex.report(__FILE__, __LINE__, __FUNCTION__);
	} catch (std::exception& ex) {
		cerr << "Got an std::exception, what=" << ex.what() << endl;
	} catch (...) {
		cerr << "Got an unknown exception" << endl;
	}
</PRE></tt>

@page CopyRightPage Copyright

Copyright 2010 ASTM E57.04 3D Imaging System File Format Committee
 
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

//! @file E57Simple.cpp

#include "E57Simple.h"
#include "E57SimpleImpl.h"

using namespace e57;
using namespace std;
using namespace boost;

////////////////////////////////////////////////////////////////////
//
//	e57::E57Root
//
	E57Root::E57Root(void)
{
};

	E57Root::~E57Root(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::Data3D
//
	Data3D::Data3D(void)
{
	originalGuids.clear();
	temperature = 0.;
	relativeHumidity = 0.;
	atmosphericPressure = 0.;

	acquisitionStart.dateTimeValue = 0.;
	acquisitionStart.isAtomicClockReferenced = 0;
	acquisitionEnd.dateTimeValue = 0.;
	acquisitionEnd.isAtomicClockReferenced = 0;

	pose.rotation.w = 1.;
	pose.rotation.x = 0.;
	pose.rotation.y = 0.;
	pose.rotation.z = 0.;
	pose.translation.x = 0.;
	pose.translation.y = 0.;
	pose.translation.z = 0.;

	cartesianBounds.xMaximum = E57_DOUBLE_MAX;
	cartesianBounds.xMinimum = -E57_DOUBLE_MAX;
	cartesianBounds.yMaximum = E57_DOUBLE_MAX;
	cartesianBounds.yMinimum = -E57_DOUBLE_MAX;
	cartesianBounds.zMaximum = E57_DOUBLE_MAX;
	cartesianBounds.zMinimum = -E57_DOUBLE_MAX;

	sphericalBounds.rangeMinimum = 0.;
	sphericalBounds.rangeMaximum = E57_DOUBLE_MAX;
	sphericalBounds.azimuthStart = 0.;
	sphericalBounds.azimuthEnd = 2 * PI;
	sphericalBounds.elevationMinimum = -PI/2.;
	sphericalBounds.elevationMaximum = PI/2.;

	indexBounds.rowMinimum = 0;
	indexBounds.rowMaximum = 0;
	indexBounds.columnMinimum = 0;
	indexBounds.columnMaximum = 0;
	indexBounds.returnMinimum = 0;
	indexBounds.returnMaximum = 0;

	pointGroupingSchemes.groupingByLine.groupsSize = 0;
	pointGroupingSchemes.groupingByLine.idElementName = "columnIndex";

	pointFields.azimuth = false;
	pointFields.colorBlue = false;
	pointFields.colorGreen = false;
	pointFields.colorRed = false;
	pointFields.columnIndex = false;
	pointFields.elevation = false;
	pointFields.intensity = false;
	pointFields.valid = false;
	pointFields.range = false;
	pointFields.returnCount = false;
	pointFields.returnIndex = false;
	pointFields.rowIndex = false;
	pointFields.timeStamp = false;
	pointFields.x = false;
	pointFields.y = false;
	pointFields.z = false;

	pointsSize = 0;
};

	Data3D::~Data3D(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::CameraImage
//
	CameraImage::CameraImage(void)
{
	acquisitionDateTime.dateTimeValue = 0.;
	acquisitionDateTime.isAtomicClockReferenced = 0;

	pose.rotation.w = 1.;
	pose.rotation.x = 0.;
	pose.rotation.y = 0.;
	pose.rotation.z = 0.;
	pose.translation.x = 0.;
	pose.translation.y = 0.;
	pose.translation.z = 0.;

	visualReferenceRepresentation.imageMask = 0;
	visualReferenceRepresentation.pngImage = 0;
	visualReferenceRepresentation.jpegImage = 0;

	pinholeRepresentation.jpegImage = 0;
	pinholeRepresentation.pngImage = 0;
	pinholeRepresentation.imageMask = 0;
	pinholeRepresentation.focalLength = 0.;
	pinholeRepresentation.imageHeight = 0;
	pinholeRepresentation.imageWidth = 0;
	pinholeRepresentation.pixelHeight = 0;
	pinholeRepresentation.pixelWidth = 0;
	pinholeRepresentation.principalPointX = 0;
	pinholeRepresentation.principalPointY = 0;

	sphericalRepresentation.jpegImage = 0;
	sphericalRepresentation.pngImage = 0;
	sphericalRepresentation.imageMask = 0;
	sphericalRepresentation.azimuthStart = 0;
	sphericalRepresentation.elevationStart = 0;
	sphericalRepresentation.imageHeight = 0;
	sphericalRepresentation.imageWidth = 0;
	sphericalRepresentation.pixelHeight = 0;
	sphericalRepresentation.pixelWidth = 0;

	cylindricalRepresentation.jpegImage = 0;
	cylindricalRepresentation.pngImage = 0;
	cylindricalRepresentation.imageMask = 0;
	cylindricalRepresentation.azimuthStart = 0;
	cylindricalRepresentation.imageHeight = 0;
	cylindricalRepresentation.imageWidth = 0;
	cylindricalRepresentation.pixelHeight = 0;
	cylindricalRepresentation.pixelWidth = 0;
	cylindricalRepresentation.principalPointY = 0;
	cylindricalRepresentation.radius = 0;
};

	CameraImage::~CameraImage(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::Reader
//
			Reader :: Reader(const ustring & filePath)
: impl_(new ReaderImpl(filePath))
{
}

bool		Reader :: IsOpen(void) const
{
	return impl_->IsOpen();
};

bool		Reader :: Close(void) const
{
	return impl_->Close();
};

bool		Reader :: GetE57Root(
	E57Root & fileHeader) const
{
	return impl_->GetE57Root(fileHeader);
};

int32_t		Reader :: GetCameraImageCount( void) const
{
	return impl_->GetCameraImageCount();
};

bool		Reader :: ReadCameraImage( 
	int32_t			imageIndex,
	CameraImage &	cameraImageHeader) const
{
	return impl_->ReadCameraImage(imageIndex,cameraImageHeader);
};

int64_t		Reader :: ReadCameraImageData(
	int32_t		imageIndex,		//!< picture block index
	void *		pBuffer,	//!< pointer the buffer
	int64_t		start,		//!< position in the block to start reading
	int64_t		count		//!< size of desired chuck or buffer size
	) const
{
	return impl_->ReadCameraImageData(imageIndex, pBuffer, start, count);
};

int32_t		Reader :: GetData3DCount( void) const
{
	return impl_->GetData3DCount();
};

bool		Reader :: ReadData3D( 
	int32_t		dataIndex,	//!< This in the index into the images3D vector
	Data3D &	data3DHeader //!< pointer to the Data3D structure to receive the image information
	) const	//!< /return Returns true if sucessful
{
	return impl_->ReadData3D(dataIndex, data3DHeader);
}

bool		Reader :: GetData3DSizes(
	int32_t		dataIndex,	//!< This in the index into the images3D vector
	int64_t &	rowMax,		//!< This is the maximum row size
	int64_t &	columnMax,	//!< This is the maximum column size
	int64_t &	pointsSize,	//!< This is the total number of point records
	int64_t &	groupsSize	//!< This is the total number of group reocrds
	) const
{
	return impl_->GetData3DSizes( dataIndex, rowMax, columnMax, pointsSize, groupsSize);
}

bool		Reader :: ReadData3DGroupsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		groupCount,			//!< size of each of the buffers given
	int64_t*	idElementValue,		//!< index for this group
	int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
	int64_t*	pointCount			//!< size of the groups given
	) const							//!< \return Return true if sucessful, false otherwise
{
	return impl_->ReadData3DGroupsData(dataIndex, groupCount, idElementValue, startPointIndex, pointCount);
}

CompressedVectorReader	Reader :: SetUpData3DPointsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		pointCount,			//!< size of each element buffer.
	int32_t*	valid,				//!< Value = 1 if the point is considered valid, 0 otherwise
	double*		cartesianX,			//!< pointer to a buffer with the X coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianY,			//!< pointer to a buffer with the Y coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianZ,			//!< pointer to a buffer with the Z coordinate (in meters) of the point in Cartesian coordinates
	double*		intensity,			//!< pointer to a buffer with the Point response intensity. Unit is unspecified
	double*		colorRed,			//!< pointer to a buffer with the Red color coefficient. Unit is unspecified
	double*		colorGreen,			//!< pointer to a buffer with the Green color coefficient. Unit is unspecified
	double*		colorBlue,			//!< pointer to a buffer with the Blue color coefficient. Unit is unspecified
	double*		sphericalRange,		//!< pointer to a buffer with the range (in meters) of points in spherical coordinates. Shall be non-negative
	double*		sphericalAzimuth,	//!< pointer to a buffer with the Azimuth angle (in radians) of point in spherical coordinates
	double*		sphericalElevation,	//!< pointer to a buffer with the Elevation angle (in radians) of point in spherical coordinates
	int64_t*	rowIndex,			//!< pointer to a buffer with the row number of point (zero based). This is useful for data that is stored in a regular grid.Shall be in the interval (0, 2^63).
	int64_t*	columnIndex,		//!< pointer to a buffer with the column number of point (zero based). This is useful for data that is stored in a regular grid. Shall be in the interval (0, 2^63).
	int64_t*	returnIndex,		//!< pointer to a buffer with the number of this return (zero based). That is, 0 is the first return, 1 is the second, and so on. Shall be in the interval (0, returnCount). Only for multi-return sensors. 
	int64_t*	returnCount,		//!< pointer to a buffer with the total number of returns for the pulse that this corresponds to. Shall be in the interval (0, 2^63). Only for multi-return sensors. 
	double*		timeStamp			//!< pointer to a buffer with the time (in seconds) since the start time for the data, which is given by acquisitionStart in the parent Data3D Structure. Shall be non-negative
	) const
{
	return impl_->SetUpData3DPointsData( dataIndex, pointCount, valid,
		cartesianX, cartesianY, cartesianZ, intensity, colorRed, colorGreen, colorBlue,
		sphericalRange, sphericalAzimuth, sphericalElevation, rowIndex, columnIndex,
		returnIndex, returnCount, timeStamp);
}

bool		Reader :: GetData3DGeneralFieldsAvailable(
	int32_t					dataIndex,
	std::vector<ustring>&	fieldsAvailable) const
{
	return impl_->GetData3DGeneralFieldsAvailable(dataIndex, fieldsAvailable);
};

int64_t		Reader :: GetData3DGeneralPoints(
	int32_t				dataIndex,
	int64_t				startPointIndex,
	int64_t				pointCount,
	bool*				valid,
	vector<ustring>&	numericFieldNames,
	vector<double*>&	numericBuffers,
	vector<ustring>&	stringFieldNames,
	vector<ustring*>&	stringBuffers) const
{
	return impl_->GetData3DGeneralPoints( dataIndex, startPointIndex, pointCount,
		valid, numericFieldNames, numericBuffers, stringFieldNames, stringBuffers);
};
////////////////////////////////////////////////////////////////////
//
//	e57::Writer
//
			Writer :: Writer(
	const ustring & filePath,		//!< file path string
	const ustring & coordinateMetaData	//!< Information describing the Coordinate Reference System to be used for the file
): impl_(new WriterImpl(filePath, coordinateMetaData))
{
}

bool		Writer :: IsOpen(void) const
{
	return impl_->IsOpen();
};

bool		Writer :: Close(void) const
{
	return impl_->Close();
};

int32_t		Writer :: NewCameraImage( 
	CameraImage &	cameraImageHeader	//!< pointer to the CameraImage structure to receive the picture information
	) const							//!< /return Returns the cameraImage index
{
	return impl_->NewCameraImage( cameraImageHeader);
};


int64_t		Writer :: WriteCameraImageData(
	int32_t		imageIndex,	//!< picture block index given by the NewCameraImage
	void *		pBuffer,	//!< pointer the buffer
	int64_t		start,		//!< position in the block to start writing
	int64_t		count		//!< size of desired chuck or buffer size
	) const						//!< /return Returns the number of bytes written
{
	return impl_->WriteCameraImageData( imageIndex, pBuffer, start, count);
};

bool		Writer :: CloseCameraImage(
	int32_t		imageIndex	//!< picture block index given by the NewCameraImage
	) const 				//!< /return Returns true if successful, false otherwise
{
	return impl_->CloseCameraImage( imageIndex);
};

int32_t		Writer :: NewData3D( 
	Data3D &	data3DHeader	//!< pointer to the Data3D structure to receive the image information
	) const							//!< /return Returns the index of the new scan's data3D block.
{
	return impl_->NewData3D( data3DHeader);
};

//! This function writes out blocks of point data
CompressedVectorWriter	Writer :: SetUpData3DPointsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		pointCount,			//!< size of each of the buffers given
	int32_t*	valid,				//!< Value = 1 if the point is considered valid, 0 otherwise
	double*		cartesianX,			//!< pointer to a buffer with the X coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianY,			//!< pointer to a buffer with the Y coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianZ,			//!< pointer to a buffer with the Z coordinate (in meters) of the point in Cartesian coordinates
	double*		intensity,			//!< pointer to a buffer with the Point response intensity. Unit is unspecified
	double*		colorRed,			//!< pointer to a buffer with the Red color coefficient. Unit is unspecified
	double*		colorGreen,			//!< pointer to a buffer with the Green color coefficient. Unit is unspecified
	double*		colorBlue,			//!< pointer to a buffer with the Blue color coefficient. Unit is unspecified
	double*		sphericalRange,		//!< pointer to a buffer with the range (in meters) of points in spherical coordinates. Shall be non-negative
	double*		sphericalAzimuth,	//!< pointer to a buffer with the Azimuth angle (in radians) of point in spherical coordinates
	double*		sphericalElevation,	//!< pointer to a buffer with the Elevation angle (in radians) of point in spherical coordinates
	int64_t*	rowIndex,			//!< pointer to a buffer with the row number of point (zero based). This is useful for data that is stored in a regular grid.Shall be in the interval (0, 2^63).
	int64_t*	columnIndex,		//!< pointer to a buffer with the column number of point (zero based). This is useful for data that is stored in a regular grid. Shall be in the interval (0, 2^63).
	int64_t*	returnIndex,		//!< pointer to a buffer with the number of this return (zero based). That is, 0 is the first return, 1 is the second, and so on. Shall be in the interval (0, returnCount). Only for multi-return sensors. 
	int64_t*	returnCount,		//!< pointer to a buffer with the total number of returns for the pulse that this corresponds to. Shall be in the interval (0, 2^63). Only for multi-return sensors. 
	double*		timeStamp			//!< pointer to a buffer with the time (in seconds) since the start time for the data, which is given by acquisitionStart in the parent Data3D Structure. Shall be non-negative
	) const
{
		return impl_->SetUpData3DPointsData( dataIndex, pointCount, valid,
		cartesianX, cartesianY, cartesianZ, intensity, colorRed, colorGreen, colorBlue,
		sphericalRange, sphericalAzimuth, sphericalElevation, rowIndex, columnIndex,
		returnIndex, returnCount, timeStamp);
}

bool		Writer :: WriteData3DGroupsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t*	idElementValue,		//!< index for this group
	int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
	int64_t*	pointCount,			//!< size of the groups given
	int32_t		count				//!< size of each of the buffers given
	) const								//!< \return Return true if sucessful, false otherwise
{
	return impl_->WriteData3DGroupsData( dataIndex, idElementValue, startPointIndex, pointCount, count);
}

//! This function sets the extensions field that will be available
bool		Writer :: SetData3DGeneralFieldsAvailable(
	int32_t					dataIndex,	//!< data block index given by the NewData3D
	std::vector<ustring>&	fieldsAvailable
	) const
{
	return impl_->SetData3DGeneralFieldsAvailable( dataIndex, fieldsAvailable);
}

//! This function writes the General data point information
int64_t		Writer :: WriteData3DGeneralPoints(
	int32_t				dataIndex,	//!< data block index given by the NewData3D
	int64_t				startPointIndex,
	int64_t				pointCount,
	bool*				valid,
	vector<ustring>&	numericFieldNames,
	vector<double*>&	numericBuffers,
	vector<ustring>&	stringFieldNames,
	vector<ustring*>&	stringBuffers
	) const
{
	return impl_->WriteData3DGeneralPoints( dataIndex, startPointIndex, pointCount,
		valid, numericFieldNames, numericBuffers, stringFieldNames, stringBuffers);
}
