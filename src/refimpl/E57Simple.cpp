//////////////////////////////////////////////////////////////////////////
//
//  E57Simple.cpp - private implementation header of E57 format reference implementation.
//
//	Copyright (c) 2010 Stan Coleby (scoleby@intelisum.com)
//	All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
// 
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//	The Boost license Vestion 1.0 - August 17th, 2003 is discussed in
//	http://www.boost.org/users/license.html.
//
//  This source code is only intended as a supplement to promote the
//	ASTM E57.04 3D Imaging System File Format standard for interoperability
//	of Lidar Data.  See http://www.libe57.org.
//
//////////////////////////////////////////////////////////////////////////
//
//	New E57Simple.cpp
//	V5		May 18, 2010	Stan Coleby		scoleby@intelisum.com
//	V6		June 8, 2010	Stan Coleby		scoleby@intelisum.com
//
//////////////////////////////////////////////////////////////////////////
/*================*/ /*!
@mainpage

@section main_Introduction Introduction
This browser-based document describes the E57 Simple API (Application Programmer Interface) version 0.52, which is a collection of functions that help a C++ programmer wrap the E57 Foundation API.

@section main_Read_example Reading using the E57 Simple API
An example of a typical use of this interface would be as follows:
<tt><PRE>
	try
	{
// Create a ReaderImpl
		_bstr_t bsFile = sFile;			//converts Unicode to UTF-8
		e57::Reader	eReader( (char*) bsFile);

///////////////////////////////////////////////////////////////
// ACCESSING ROOT DATA

// Read the root
		e57::E57Root	rootHeader;
		eReader.GetE57Root( rootHeader);		

//Access all the root information like
		char* fileGuid = rootHeader.guid.c_str();
		...

///////////////////////////////////////////////////////////////
// ACCESSING SCAN DATA3D

//Get the number of scan images available
		int data3DCount = eReader.GetData3DCount();

//selecting the first scan
		int scanIndex = 0;

//Read the scan 0 header.
		e57::Data3D		scanHeader;
		eReader.ReadData3D( scanIndex, scanHeader);

//Access all the header information like
		char* scanGuid = scanHeader.guid.c_str();
		...

/////////////////////////////////////////////////////////////////
// ACCESSING SCAN DATA

//Get the Size of the Scan
		int64_t nColumn = 0;	
		int64_t nRow = 0;
		int64_t nPointsSize = 0;	//Number of points
		int64_t nGroupsSize = 0;	//Number of groups
		eReader.GetData3DSizes( scanIndex, nRow, nColumn, nPointsSize, nGroupsSize);

//Set up buffers
		double* xBuffer = new double[nPointsSize];
		double* yBuffer = new double[nPointsSize];
		double* zBuffer = new double[nPointsSize];
		CompressedVectorReader dataReader = eReader.SetUpData3DPointsData(
			scanIndex, nPointsSize, NULL, xBuffer, yBuffer, zBuffer);

//Read the point data
		dataReader.read();

// ... access the data ...

//Close and clean up
		dataReader.close();
		delete xBuffer;
		delete yBuffer;
		delete zBuffer;

///////////////////////////////////////////////////////////////////////
// ACCESSING PICTURE IMAGE2D

//Get the number of picture images available
		int image2DCount = eReader.GetImage2DCount();

//selecting the first picture
		int pictureIndex = 0;

//Read the picture 0 header.
		e57::Image2D	pictureHeader;
		eReader.ReadData3D( pictureIndex, pictureHeader);

//Access all the header information like
		char* pictureGuid = pictureHeader.guid.c_str();
		...

///////////////////////////////////////////////////////////////////////
// ACCESSING PICTURE IMAGE

//Get the Size of the Picture
		e57::Image2DProjection	imageProjection;	//like E57_SPHERICAL
		e57::Image2DType	imageType;		//like E57_JPEG_IMAGE
		int64_t			nImageWidth = 0;	
		int64_t			nImageHeight = 0;
		int64_t			nImagesSize = 0;	//Number of bytes in the image
		e57::Image2DType	imageMaskType;		//like E57_PNG_IMAGE_MASK if present
		e57::Image2dType	imageVisualType;	//like E57_JPEG_IMAGE if present

		eReader.GetImage2DSizes( pictureIndex, imageProjection, imageType,
			nImageWidth, nImageHeight, nImagesSize, imageMaskType, imageVisualType);

//Set up buffers
		void* jpegBuffer = new char[nImagesSize];

//Read the picture data
		eReader.ReadImage2DData(pictureIndex, imageProjection, imageType, jpegBuffer, 0, nImagesSizw);

// ... access the picture and decode ...

//Close and clean up
		delete jpegBuffer;

		eReaer.Close();	

///////////////////////////////////////////////////////////////////////
// CATCH THE ERRORS

	} catch(E57Exception& ex) {
		ex.report(__FILE__, __LINE__, __FUNCTION__);
	} catch (std::exception& ex) {
		cerr << "Got an std::exception, what=" << ex.what() << endl;
	} catch (...) {
		cerr << "Got an unknown exception" << endl;
	}
</PRE></tt>

@page CopyRightPage Copyright

Copyright 2010 ASTM E57.04 3D Imaging System File Format Committee
 
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

//! @file E57Simple.cpp

#include "E57Simple.h"
#include "E57SimpleImpl.h"

using namespace e57;
using namespace std;
using namespace boost;

////////////////////////////////////////////////////////////////////
//
//	e57::E57Root
//
	E57Root::E57Root(void)
{
};

	E57Root::~E57Root(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::Data3D
//
	Data3D::Data3D(void)
{
	originalGuids.clear();
	temperature = 0.;
	relativeHumidity = 0.;
	atmosphericPressure = 0.;

	acquisitionStart.dateTimeValue = 0.;
	acquisitionStart.isAtomicClockReferenced = 0;
	acquisitionEnd.dateTimeValue = 0.;
	acquisitionEnd.isAtomicClockReferenced = 0;

	pose.rotation.w = 1.;
	pose.rotation.x = 0.;
	pose.rotation.y = 0.;
	pose.rotation.z = 0.;
	pose.translation.x = 0.;
	pose.translation.y = 0.;
	pose.translation.z = 0.;

	cartesianBounds.xMaximum = E57_DOUBLE_MAX;
	cartesianBounds.xMinimum = -E57_DOUBLE_MAX;
	cartesianBounds.yMaximum = E57_DOUBLE_MAX;
	cartesianBounds.yMinimum = -E57_DOUBLE_MAX;
	cartesianBounds.zMaximum = E57_DOUBLE_MAX;
	cartesianBounds.zMinimum = -E57_DOUBLE_MAX;

	sphericalBounds.rangeMinimum = 0.;
	sphericalBounds.rangeMaximum = E57_DOUBLE_MAX;
	sphericalBounds.azimuthStart = 0.;
	sphericalBounds.azimuthEnd = 2 * PI;
	sphericalBounds.elevationMinimum = -PI/2.;
	sphericalBounds.elevationMaximum = PI/2.;

	indexBounds.rowMinimum = 0;
	indexBounds.rowMaximum = 0;
	indexBounds.columnMinimum = 0;
	indexBounds.columnMaximum = 0;
	indexBounds.returnMinimum = 0;
	indexBounds.returnMaximum = 0;

	pointGroupingSchemes.groupingByLine.groupsSize = 0;
	pointGroupingSchemes.groupingByLine.idElementName = "columnIndex";

	pointFields.azimuth = false;
	pointFields.colorBlue = false;
	pointFields.colorGreen = false;
	pointFields.colorRed = false;
	pointFields.columnIndex = false;
	pointFields.elevation = false;
	pointFields.intensity = false;
	pointFields.valid = false;
	pointFields.range = false;
	pointFields.returnCount = false;
	pointFields.returnIndex = false;
	pointFields.rowIndex = false;
	pointFields.timeStamp = false;
	pointFields.x = false;
	pointFields.y = false;
	pointFields.z = false;

	pointsSize = 0;
};

	Data3D::~Data3D(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::Image2D
//
	Image2D::Image2D(void)
{
	acquisitionDateTime.dateTimeValue = 0.;
	acquisitionDateTime.isAtomicClockReferenced = 0;

	pose.rotation.w = 1.;
	pose.rotation.x = 0.;
	pose.rotation.y = 0.;
	pose.rotation.z = 0.;
	pose.translation.x = 0.;
	pose.translation.y = 0.;
	pose.translation.z = 0.;

	visualReferenceRepresentation.imageMask = 0;
	visualReferenceRepresentation.pngImage = 0;
	visualReferenceRepresentation.jpegImage = 0;

	pinholeRepresentation.jpegImage = 0;
	pinholeRepresentation.pngImage = 0;
	pinholeRepresentation.imageMask = 0;
	pinholeRepresentation.focalLength = 0.;
	pinholeRepresentation.imageHeight = 0;
	pinholeRepresentation.imageWidth = 0;
	pinholeRepresentation.pixelHeight = 0;
	pinholeRepresentation.pixelWidth = 0;
	pinholeRepresentation.principalPointX = 0;
	pinholeRepresentation.principalPointY = 0;

	sphericalRepresentation.jpegImage = 0;
	sphericalRepresentation.pngImage = 0;
	sphericalRepresentation.imageMask = 0;
	sphericalRepresentation.imageHeight = 0;
	sphericalRepresentation.imageWidth = 0;
	sphericalRepresentation.pixelHeight = 0;
	sphericalRepresentation.pixelWidth = 0;

	cylindricalRepresentation.jpegImage = 0;
	cylindricalRepresentation.pngImage = 0;
	cylindricalRepresentation.imageMask = 0;
	cylindricalRepresentation.imageHeight = 0;
	cylindricalRepresentation.imageWidth = 0;
	cylindricalRepresentation.pixelHeight = 0;
	cylindricalRepresentation.pixelWidth = 0;
	cylindricalRepresentation.principalPointY = 0;
	cylindricalRepresentation.radius = 0;
};

	Image2D::~Image2D(void)
{
};
////////////////////////////////////////////////////////////////////
//
//	e57::Reader
//
			Reader :: Reader(const ustring & filePath)
: impl_(new ReaderImpl(filePath))
{
}

bool		Reader :: IsOpen(void) const
{
	return impl_->IsOpen();
};

bool		Reader :: Close(void) const
{
	return impl_->Close();
};

bool		Reader :: GetE57Root(
	E57Root & fileHeader) const
{
	return impl_->GetE57Root(fileHeader);
};

int32_t		Reader :: GetImage2DCount( void) const
{
	return impl_->GetImage2DCount();
};

bool		Reader :: ReadImage2D( 
	int32_t			imageIndex,
	Image2D &	image2DHeader) const
{
	return impl_->ReadImage2D(imageIndex,image2DHeader);
};

bool		Reader :: GetImage2DSizes(
	int32_t					imageIndex,		//!< This in the index into the image2D vector
	e57::Image2DProjection &imageProjection,//!< identifies the projection desired.
	e57::Image2DType &		imageType,		//!< identifies the image format desired.
	int64_t &				imageWidth,		//!< The image width (in pixels).
	int64_t &				imageHeight,	//!< The image height (in pixels).
	int64_t &				imageSize,		//!< This is the total number of bytes for the image blob.
	e57::Image2DType &		imageMaskType,	//!< This is E57_PNG_IMAGE_MASK if "imageMask" is defined in the projection
	e57::Image2DType &		imageVisualType	//!< This is image type of the VisualReferenceRepresentation if given.
	) const
{
	return impl_->GetImage2DSizes(imageIndex, imageProjection, imageType,
		imageWidth, imageHeight, imageSize, imageMaskType, imageVisualType);
};

int64_t		Reader :: ReadImage2DData(
	int32_t					imageIndex,		//!< picture block index
	e57::Image2DProjection	imageProjection,//!< identifies the projection desired.
	e57::Image2DType		imageType,		//!< identifies the image format desired.
	void *					pBuffer,	//!< pointer the buffer
	int64_t					start,		//!< position in the block to start reading
	int64_t					count		//!< size of desired chuck or buffer size
	) const
{
	return impl_->ReadImage2DData(imageIndex, imageProjection, imageType, pBuffer, start, count);
};

int32_t		Reader :: GetData3DCount( void) const
{
	return impl_->GetData3DCount();
};

//! This function returns the file raw E57Root Structure Node
StructureNode	Reader :: GetRawE57Root(void)
{
	return impl_->GetRawE57Root();
};	//!< /return Returns the E57Root StructureNode

//! This function returns the raw Data3D Vector Node
VectorNode		Reader :: GetRawData3D(void)
{
	return impl_->GetRawData3D();
};//!< /return Returns the raw Data3D VectorNode

//! This function returns the raw Image2D Vector Node
VectorNode		Reader :: GetRawImage2D(void)
{
	return impl_->GetRawImage2D();
};	//!< /return Returns the raw Image2D VectorNode

bool		Reader :: ReadData3D( 
	int32_t		dataIndex,	//!< This in the index into the images3D vector
	Data3D &	data3DHeader //!< pointer to the Data3D structure to receive the image information
	) const	//!< /return Returns true if sucessful
{
	return impl_->ReadData3D(dataIndex, data3DHeader);
}

bool		Reader :: GetData3DSizes(
	int32_t		dataIndex,	//!< This in the index into the images3D vector
	int64_t &	rowMax,		//!< This is the maximum row size
	int64_t &	columnMax,	//!< This is the maximum column size
	int64_t &	pointsSize,	//!< This is the total number of point records
	int64_t &	groupsSize	//!< This is the total number of group reocrds
	) const
{
	return impl_->GetData3DSizes( dataIndex, rowMax, columnMax, pointsSize, groupsSize);
}

bool		Reader :: ReadData3DGroupsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		groupCount,			//!< size of each of the buffers given
	int64_t*	idElementValue,		//!< index for this group
	int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
	int64_t*	pointCount			//!< size of the groups given
	) const							//!< \return Return true if sucessful, false otherwise
{
	return impl_->ReadData3DGroupsData(dataIndex, groupCount, idElementValue, startPointIndex, pointCount);
}

CompressedVectorReader	Reader :: SetUpData3DPointsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		pointCount,			//!< size of each element buffer.
	int32_t*	valid,				//!< Value = 1 if the point is considered valid, 0 otherwise
	double*		cartesianX,			//!< pointer to a buffer with the X coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianY,			//!< pointer to a buffer with the Y coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianZ,			//!< pointer to a buffer with the Z coordinate (in meters) of the point in Cartesian coordinates
	double*		intensity,			//!< pointer to a buffer with the Point response intensity. Unit is unspecified
	double*		colorRed,			//!< pointer to a buffer with the Red color coefficient. Unit is unspecified
	double*		colorGreen,			//!< pointer to a buffer with the Green color coefficient. Unit is unspecified
	double*		colorBlue,			//!< pointer to a buffer with the Blue color coefficient. Unit is unspecified
	double*		sphericalRange,		//!< pointer to a buffer with the range (in meters) of points in spherical coordinates. Shall be non-negative
	double*		sphericalAzimuth,	//!< pointer to a buffer with the Azimuth angle (in radians) of point in spherical coordinates
	double*		sphericalElevation,	//!< pointer to a buffer with the Elevation angle (in radians) of point in spherical coordinates
	int64_t*	rowIndex,			//!< pointer to a buffer with the row number of point (zero based). This is useful for data that is stored in a regular grid.Shall be in the interval (0, 2^63).
	int64_t*	columnIndex,		//!< pointer to a buffer with the column number of point (zero based). This is useful for data that is stored in a regular grid. Shall be in the interval (0, 2^63).
	int64_t*	returnIndex,		//!< pointer to a buffer with the number of this return (zero based). That is, 0 is the first return, 1 is the second, and so on. Shall be in the interval (0, returnCount). Only for multi-return sensors. 
	int64_t*	returnCount,		//!< pointer to a buffer with the total number of returns for the pulse that this corresponds to. Shall be in the interval (0, 2^63). Only for multi-return sensors. 
	double*		timeStamp			//!< pointer to a buffer with the time (in seconds) since the start time for the data, which is given by acquisitionStart in the parent Data3D Structure. Shall be non-negative
	) const
{
	return impl_->SetUpData3DPointsData( dataIndex, pointCount, valid,
		cartesianX, cartesianY, cartesianZ, intensity, colorRed, colorGreen, colorBlue,
		sphericalRange, sphericalAzimuth, sphericalElevation, rowIndex, columnIndex,
		returnIndex, returnCount, timeStamp);
}

////////////////////////////////////////////////////////////////////
//
//	e57::Writer
//
			Writer :: Writer(
	const ustring & filePath,		//!< file path string
	const ustring & coordinateMetaData	//!< Information describing the Coordinate Reference System to be used for the file
): impl_(new WriterImpl(filePath, coordinateMetaData))
{
}

bool		Writer :: IsOpen(void) const
{
	return impl_->IsOpen();
};

bool		Writer :: Close(void) const
{
	return impl_->Close();
};
//! This function returns the file raw E57Root Structure Node
StructureNode	Writer :: GetRawE57Root(void)
{
	return impl_->GetRawE57Root();
};	//!< /return Returns the E57Root StructureNode

//! This function returns the raw Data3D Vector Node
VectorNode		Writer :: GetRawData3D(void)
{
	return impl_->GetRawData3D();
};//!< /return Returns the raw Data3D VectorNode

//! This function returns the raw Image2D Vector Node
VectorNode		Writer :: GetRawImage2D(void)
{
	return impl_->GetRawImage2D();
};	//!< /return Returns the raw Image2D VectorNode

int32_t		Writer :: NewImage2D( 
	Image2D &	image2DHeader	//!< pointer to the Image2D structure to receive the picture information
	) const						//!< /return Returns the image2D index
{
	return impl_->NewImage2D( image2DHeader);
};


int64_t		Writer :: WriteImage2DData(
	int32_t					imageIndex,		//!< picture block index given by the NewImage2D
	e57::Image2DType		imageType,		//!< identifies the image format desired.
	e57::Image2DProjection	imageProjection,//!< identifies the projection desired.
	void *					pBuffer,		//!< pointer the buffer
	int64_t					start,			//!< position in the block to start writing
	int64_t					count			//!< size of desired chuck or buffer size
	) const									//!< /return Returns the number of bytes written
{
	return impl_->WriteImage2DData( imageIndex, imageType, imageProjection, pBuffer, start, count);
};

bool		Writer :: CloseImage2D(
	int32_t		imageIndex	//!< picture block index given by the NewImage2D
	) const 				//!< /return Returns true if successful, false otherwise
{
	return impl_->CloseImage2D( imageIndex);
};

int32_t		Writer :: NewData3D( 
	Data3D &	data3DHeader	//!< pointer to the Data3D structure to receive the image information
	) const							//!< /return Returns the index of the new scan's data3D block.
{
	return impl_->NewData3D( data3DHeader);
};

//! This function writes out blocks of point data
CompressedVectorWriter	Writer :: SetUpData3DPointsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t		pointCount,			//!< size of each of the buffers given
	int32_t*	valid,				//!< Value = 1 if the point is considered valid, 0 otherwise
	double*		cartesianX,			//!< pointer to a buffer with the X coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianY,			//!< pointer to a buffer with the Y coordinate (in meters) of the point in Cartesian coordinates
	double*		cartesianZ,			//!< pointer to a buffer with the Z coordinate (in meters) of the point in Cartesian coordinates
	double*		intensity,			//!< pointer to a buffer with the Point response intensity. Unit is unspecified
	double*		colorRed,			//!< pointer to a buffer with the Red color coefficient. Unit is unspecified
	double*		colorGreen,			//!< pointer to a buffer with the Green color coefficient. Unit is unspecified
	double*		colorBlue,			//!< pointer to a buffer with the Blue color coefficient. Unit is unspecified
	double*		sphericalRange,		//!< pointer to a buffer with the range (in meters) of points in spherical coordinates. Shall be non-negative
	double*		sphericalAzimuth,	//!< pointer to a buffer with the Azimuth angle (in radians) of point in spherical coordinates
	double*		sphericalElevation,	//!< pointer to a buffer with the Elevation angle (in radians) of point in spherical coordinates
	int64_t*	rowIndex,			//!< pointer to a buffer with the row number of point (zero based). This is useful for data that is stored in a regular grid.Shall be in the interval (0, 2^63).
	int64_t*	columnIndex,		//!< pointer to a buffer with the column number of point (zero based). This is useful for data that is stored in a regular grid. Shall be in the interval (0, 2^63).
	int64_t*	returnIndex,		//!< pointer to a buffer with the number of this return (zero based). That is, 0 is the first return, 1 is the second, and so on. Shall be in the interval (0, returnCount). Only for multi-return sensors. 
	int64_t*	returnCount,		//!< pointer to a buffer with the total number of returns for the pulse that this corresponds to. Shall be in the interval (0, 2^63). Only for multi-return sensors. 
	double*		timeStamp			//!< pointer to a buffer with the time (in seconds) since the start time for the data, which is given by acquisitionStart in the parent Data3D Structure. Shall be non-negative
	) const
{
		return impl_->SetUpData3DPointsData( dataIndex, pointCount, valid,
		cartesianX, cartesianY, cartesianZ, intensity, colorRed, colorGreen, colorBlue,
		sphericalRange, sphericalAzimuth, sphericalElevation, rowIndex, columnIndex,
		returnIndex, returnCount, timeStamp);
}

bool		Writer :: WriteData3DGroupsData(
	int32_t		dataIndex,			//!< data block index given by the NewData3D
	int64_t*	idElementValue,		//!< index for this group
	int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
	int64_t*	pointCount,			//!< size of the groups given
	int32_t		count				//!< size of each of the buffers given
	) const								//!< \return Return true if sucessful, false otherwise
{
	return impl_->WriteData3DGroupsData( dataIndex, idElementValue, startPointIndex, pointCount, count);
}

