//////////////////////////////////////////////////////////////////////////
//
//  E57SimpleImpl.cpp - private implementation header of E57 format reference implementation.
//
//	Copyright (c) 2010 Stan Coleby (scoleby@intelisum.com)
//	All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
// 
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//	The Boost license Vestion 1.0 - August 17th, 2003 is discussed in
//	http://www.boost.org/users/license.html.
//
//  This source code is only intended as a supplement to promote the
//	ASTM E57.04 3D Imaging System File Format standard for interoperability
//	of Lidar Data.  See http://www.libe57.org.
//
//////////////////////////////////////////////////////////////////////////
//
//	New E57SimpleImpl.cpp
//	V1		May 18, 2010	Stan Coleby		scoleby@intelisum.com
//
//////////////////////////////////////////////////////////////////////////

//! @file E57SimpleImpl.cpp

#if defined(WIN32)
#  if defined(_MSC_VER)
#    include <io.h>
#    include <fcntl.h>
#    include <sys\stat.h>
#    include <windows.h>
#  elif defined(__GNUC__)
#  define _LARGEFILE64_SOURCE
#  define __LARGE64_FILES
#  include <sys/types.h>
#  include <unistd.h>

#    include <fcntl.h>
#    include <sys\stat.h>
#  else
#    error "no supported compiler defined"
#  endif
#elif defined(LINUX)
#  define _LARGEFILE64_SOURCE
#  define __LARGE64_FILES
#  include <sys/types.h>
#  include <unistd.h>
#else
#  error "no supported OS platform defined"
#endif




#include <sstream>
#include "E57SimpleImpl.h"

using namespace e57;
using namespace std;
using namespace boost;

////////////////////////////////////////////////////////////////////
//
//	e57::ReaderImpl
//
	ReaderImpl::ReaderImpl(
		const ustring & filePath)
	: imf_(filePath,"r")
	, root_(imf_.root())
	, data3D_(root_.get("/data3D"))
	, cameraImages_(root_.get("/cameraImages"))
{
};

	ReaderImpl::~ReaderImpl(void)
{
	if(IsOpen())
		Close();
};


//! This function returns true if the file is open
bool	ReaderImpl :: IsOpen(void)
{
	if( imf_.isOpen())
		return true;
	return false;
};

//! This function closes the file
bool	ReaderImpl :: Close(void)
{
	if(IsOpen())
	{
		imf_.close();
		return true;
	}
	return false;
};

////////////////////////////////////////////////////////////////////
//
//	File information
//
//! This function returns the file header information
bool	ReaderImpl :: GetE57Root(
	E57Root & fileHeader)	//!< This is the main header information
{
	if(IsOpen())
	{
		fileHeader.formatName = StringNode(root_.get("formatName")).value();
		fileHeader.versionMajor = (int32_t) IntegerNode(root_.get("versionMajor")).value();
		fileHeader.versionMinor = (int32_t) IntegerNode(root_.get("versionMinor")).value();
		fileHeader.guid = StringNode(root_.get("guid")).value();

		if(root_.isDefined("coordinateMetadata"))
			fileHeader.coordinateMetadata = StringNode(root_.get("coordinateMetadata")).value();

		if(root_.isDefined("creationDateTime"))
		{
			StructureNode creationDateTime(root_.get("creationDateTime"));
			fileHeader.creationDateTime.dateTimeValue = FloatNode(creationDateTime.get("dateTimeValue")).value();
			fileHeader.creationDateTime.isGpsReferenced = (int32_t) IntegerNode(creationDateTime.get("isGpsReferenced")).value();
		}

		fileHeader.data3DSize = (int32_t) data3D_.childCount();
		fileHeader.cameraImagesSize = (int32_t) cameraImages_.childCount();

		return true;
	}
	return false;
};

////////////////////////////////////////////////////////////////////
//
//	Camera Image picture data
//
//! This function returns the total number of Picture Blocks
int32_t	ReaderImpl :: GetCameraImageCount( void)
{
	return (int32_t) cameraImages_.childCount();
};

//! This function returns the cameraImages header and positions the cursor
bool	ReaderImpl :: ReadCameraImage( 
	int32_t			imageIndex,		//!< This in the index into the cameraImages vector
	CameraImage &	cameraImageHeader	//!< pointer to the CameraImage structure to receive the picture information
	)						//!< /return Returns true if sucessful
{
	if(IsOpen())
	{
		if( (imageIndex < 0) || (imageIndex >= cameraImages_.childCount()))
			return false;

		StructureNode image(cameraImages_.get(imageIndex));

		cameraImageHeader.guid = StringNode(image.get("guid")).value();

		if(image.isDefined("name"))
			cameraImageHeader.name = StringNode(image.get("name")).value();

		if(image.isDefined("description"))
			cameraImageHeader.description = StringNode(image.get("description")).value();

		if(image.isDefined("sensorVendor"))
			cameraImageHeader.sensorVendor = StringNode(image.get("sensorVendor")).value();
		if(image.isDefined("sensorModel"))
			cameraImageHeader.sensorModel = StringNode(image.get("sensorModel")).value();
		if(image.isDefined("sensorSerialNumber"))
			cameraImageHeader.sensorSerialNumber = StringNode(image.get("sensorSerialNumber")).value();

		if(image.isDefined("associatedData3DGuid"))
			cameraImageHeader.associatedData3DGuid = StringNode(image.get("associatedData3DGuid")).value();

		if(image.isDefined("acquisitionDateTime"))
		{
			StructureNode acquisitionDateTime(image.get("acquisitionDateTime"));
			cameraImageHeader.acquisitionDateTime.dateTimeValue = 
				FloatNode(acquisitionDateTime.get("dateTimeValue")).value();
			cameraImageHeader.acquisitionDateTime.isGpsReferenced = (int32_t) 
				IntegerNode(acquisitionDateTime.get("isAtomicClockReferenced")).value();
		}
// Get pose structure for scan.

		if(image.isDefined("pose"))
		{
			StructureNode pose(image.get("pose"));
			StructureNode rotation(pose.get("rotation"));
			StructureNode translation(pose.get("translation"));

			cameraImageHeader.pose.rotation.w = FloatNode(rotation.get("w")).value();
			cameraImageHeader.pose.rotation.x = FloatNode(rotation.get("x")).value();
			cameraImageHeader.pose.rotation.y = FloatNode(rotation.get("y")).value();
			cameraImageHeader.pose.rotation.z = FloatNode(rotation.get("z")).value();
  
			cameraImageHeader.pose.translation.x = FloatNode(translation.get("x")).value();
			cameraImageHeader.pose.translation.y = FloatNode(translation.get("y")).value();
			cameraImageHeader.pose.translation.z = FloatNode(translation.get("z")).value();
		}

		if(image.isDefined("visualReferenceRepresentation"))
		{
			StructureNode visualReferenceRepresentation(image.get("visualReferenceRepresentation"));

			cameraImageHeader.visualReferenceRepresentation.jpegImage = 
				BlobNode(visualReferenceRepresentation.get("jpegImage")).byteCount();
			cameraImageHeader.visualReferenceRepresentation.pngImage = 
				BlobNode(visualReferenceRepresentation.get("pngImage")).byteCount();
			cameraImageHeader.visualReferenceRepresentation.imageMask = 
				BlobNode(visualReferenceRepresentation.get("imageMask")).byteCount();
		}
		else if(image.isDefined("pinholeRepresentation"))
		{
			StructureNode pinholeRepresentation(image.get("pinholeRepresentation"));

			cameraImageHeader.pinholeRepresentation.jpegImage = 
				BlobNode(pinholeRepresentation.get("jpegImage")).byteCount();
			cameraImageHeader.pinholeRepresentation.pngImage = 
				BlobNode(pinholeRepresentation.get("pngImage")).byteCount();
			cameraImageHeader.pinholeRepresentation.imageMask = 
				BlobNode(pinholeRepresentation.get("imageMask")).byteCount();

			cameraImageHeader.pinholeRepresentation.focalLength = 
				FloatNode(pinholeRepresentation.get("focalLength")).value();
			cameraImageHeader.pinholeRepresentation.imageHeight = (int32_t)
				IntegerNode(pinholeRepresentation.get("imageHeight")).value();
			cameraImageHeader.pinholeRepresentation.imageWidth = (int32_t)
				IntegerNode(pinholeRepresentation.get("imageWidth")).value();
			cameraImageHeader.pinholeRepresentation.pixelHeight = 
				FloatNode(pinholeRepresentation.get("pixelHeight")).value();
			cameraImageHeader.pinholeRepresentation.pixelWidth = 
				FloatNode(pinholeRepresentation.get("pixelWidth")).value();
			cameraImageHeader.pinholeRepresentation.principalPointX = 
				FloatNode(pinholeRepresentation.get("principalPointX")).value();
			cameraImageHeader.pinholeRepresentation.principalPointY = 
				FloatNode(pinholeRepresentation.get("principalPointY")).value();
		}
		else if(image.isDefined("sphericalRepresentation"))
		{
			StructureNode sphericalRepresentation(image.get("sphericalRepresentation"));

			cameraImageHeader.sphericalRepresentation.jpegImage = 
				BlobNode(sphericalRepresentation.get("jpegImage")).byteCount();
			cameraImageHeader.sphericalRepresentation.pngImage = 
				BlobNode(sphericalRepresentation.get("pngImage")).byteCount();
			cameraImageHeader.sphericalRepresentation.imageMask = 
				BlobNode(sphericalRepresentation.get("imageMask")).byteCount();

			cameraImageHeader.sphericalRepresentation.azimuthStart = 
				FloatNode(sphericalRepresentation.get("azimuthStart")).value();
			cameraImageHeader.sphericalRepresentation.elevationStart = 
				FloatNode(sphericalRepresentation.get("elevationStart")).value();
			cameraImageHeader.sphericalRepresentation.imageHeight = (int32_t)
				IntegerNode(sphericalRepresentation.get("imageHeight")).value();
			cameraImageHeader.sphericalRepresentation.imageWidth = (int32_t)
				IntegerNode(sphericalRepresentation.get("imageWidth")).value();
			cameraImageHeader.sphericalRepresentation.pixelHeight = 
				FloatNode(sphericalRepresentation.get("pixelHeight")).value();
			cameraImageHeader.sphericalRepresentation.pixelWidth = 
				FloatNode(sphericalRepresentation.get("pixelWidth")).value();
		}
		else if(image.isDefined("cylindricalRepresentation"))
		{
			StructureNode cylindricalRepresentation(image.get("cylindricalRepresentation"));

			cameraImageHeader.cylindricalRepresentation.jpegImage = 
				BlobNode(cylindricalRepresentation.get("jpegImage")).byteCount();
			cameraImageHeader.cylindricalRepresentation.pngImage = 
				BlobNode(cylindricalRepresentation.get("pngImage")).byteCount();
			cameraImageHeader.cylindricalRepresentation.imageMask = 
				BlobNode(cylindricalRepresentation.get("imageMask")).byteCount();

			cameraImageHeader.cylindricalRepresentation.azimuthStart = 
				FloatNode(cylindricalRepresentation.get("azimuthStart")).value();
			cameraImageHeader.cylindricalRepresentation.imageHeight = (int32_t)
				IntegerNode(cylindricalRepresentation.get("imageHeight")).value();
			cameraImageHeader.cylindricalRepresentation.imageWidth = (int32_t)
				IntegerNode(cylindricalRepresentation.get("imageWidth")).value();
			cameraImageHeader.cylindricalRepresentation.pixelHeight = 
				FloatNode(cylindricalRepresentation.get("pixelHeight")).value();
			cameraImageHeader.cylindricalRepresentation.pixelWidth = 
				FloatNode(cylindricalRepresentation.get("pixelWidth")).value();
			cameraImageHeader.cylindricalRepresentation.principalPointY = 
				FloatNode(cylindricalRepresentation.get("principalPointY")).value();
			cameraImageHeader.cylindricalRepresentation.radius = 
				FloatNode(cylindricalRepresentation.get("radius")).value();
		}
		return true;
	}
	return false;
};

//! This function reads the block
int64_t	ReaderImpl :: ReadCameraImageData(
	int32_t		imageIndex,		//!< picture block index
	void *		pBuffer,	//!< pointer the buffer
	int64_t		start,		//!< position in the block to start reading
	int64_t		count		//!< size of desired chuck or buffer size
	)						//!< /return Returns the number of bytes transferred.
{
	if( (imageIndex < 0) || (imageIndex >= cameraImages_.childCount()))
		return 0;

///////////  This is a problem because we have to do this for every call
	StructureNode image(cameraImages_.get(imageIndex));

	if(image.isDefined("visualReferenceRepresentation"))
	{
		StructureNode visualReferenceRepresentation(image.get("visualReferenceRepresentation"));
		if(visualReferenceRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(visualReferenceRepresentation.get("jpegImage"));
			jpegImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(visualReferenceRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(visualReferenceRepresentation.get("pngImage"));
			pngImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(visualReferenceRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(visualReferenceRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("pinholeRepresentation"))
	{
		StructureNode pinholeRepresentation(image.get("pinholeRepresentation"));
		if(pinholeRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(pinholeRepresentation.get("jpegImage"));
			jpegImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(pinholeRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(pinholeRepresentation.get("pngImage"));
			pngImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(pinholeRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(pinholeRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("sphericalRepresentation"))
	{
		StructureNode sphericalRepresentation(image.get("sphericalRepresentation"));
		if(sphericalRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(sphericalRepresentation.get("jpegImage"));
			jpegImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(sphericalRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(sphericalRepresentation.get("pngImage"));
			pngImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(sphericalRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(sphericalRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("cylindricalRepresentation"))
	{
		StructureNode cylindricalRepresentation(image.get("cylindricalRepresentation"));
		if(cylindricalRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(cylindricalRepresentation.get("jpegImage"));
			jpegImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(cylindricalRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(cylindricalRepresentation.get("pngImage"));
			pngImage.read((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(cylindricalRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(cylindricalRepresentation.get("imageMask"));
//			}
	}
	return count;

};

////////////////////////////////////////////////////////////////////
//
//	Scanner Image 3d data
//
//! This function returns the total number of Image Blocks
int32_t	ReaderImpl :: GetData3DCount( void)
{
	return (int32_t) data3D_.childCount();
};

//! This function returns the Data3D header and positions the cursor
bool	ReaderImpl :: ReadData3D( 
	int32_t		dataIndex,	//!< This in the index into the images3D vector
	Data3D &	data3DHeader //!< pointer to the Data3D structure to receive the image information
	)	//!< /return Returns true if sucessful
{
	if(IsOpen())
	{
		if( (dataIndex < 0) || (dataIndex >= data3D_.childCount()))
			return false;

		StructureNode scan(data3D_.get(dataIndex));
		CompressedVectorNode points(scan.get("points"));

		data3DHeader.pointsSize = points.childCount();
		StructureNode proto(points.prototype());

		data3DHeader.guid = StringNode(scan.get("guid")).value();

		if(scan.isDefined("name"))
			data3DHeader.name = StringNode(scan.get("name")).value();
		if(scan.isDefined("description"))
			data3DHeader.description = StringNode(scan.get("description")).value();

		if(scan.isDefined("pointGroupingSchemes"))
		{
			StructureNode pointGroupingSchemes(scan.get("pointGroupingSchemes"));
			StructureNode groupingByLine(pointGroupingSchemes.get("groupingByLine"));
			CompressedVectorNode groups(groupingByLine.get("groups"));

			data3DHeader.pointGroupingSchemes.groupingByLine.groupsSize = groups.childCount();
			StructureNode lineProto(groups.prototype());

			data3DHeader.pointGroupingSchemes.groupingByLine.idElementName =
				StringNode(groupingByLine.get("idElementName")).value();
		}

// Get various sensor and version strings to scan.

		if(scan.isDefined("sensorVendor"))
			data3DHeader.sensorVendor = StringNode(scan.get("sensorVendor")).value();
		if(scan.isDefined("sensorModel"))
			data3DHeader.sensorModel = StringNode(scan.get("sensorModel")).value();
		if(scan.isDefined("sensorSerialNumber"))
			data3DHeader.sensorSerialNumber = StringNode(scan.get("sensorSerialNumber")).value();
		if(scan.isDefined("sensorHardwareVersion"))
			data3DHeader.sensorHardwareVersion = StringNode(scan.get("sensorHardwareVersion")).value();
		if(scan.isDefined("sensorSoftwareVersion"))
			data3DHeader.sensorSoftwareVersion = StringNode(scan.get("sensorSoftwareVersion")).value();
		if(scan.isDefined("sensorFirmwareVersion"))
			data3DHeader.sensorFirmwareVersion = StringNode(scan.get("sensorFirmwareVersion")).value();

// Get temp/humidity to scan.

		if(scan.isDefined("temperature"))
			data3DHeader.temperature = (float) FloatNode(scan.get("temperature")).value();
		if(scan.isDefined("relativeHumidity"))
			data3DHeader.relativeHumidity = (float) FloatNode(scan.get("relativeHumidity")).value();
		if(scan.isDefined("atmosphericPressure"))
			data3DHeader.atmosphericPressure = (float) FloatNode(scan.get("atmosphericPressure")).value();

		if(scan.isDefined("indexBounds"))
		{
			StructureNode ibox(scan.get("indexBounds"));
			data3DHeader.indexBounds.rowMinimum = IntegerNode(ibox.get("rowMinimum")).value();
			data3DHeader.indexBounds.rowMaximum = IntegerNode(ibox.get("rowMaximum")).value();
			data3DHeader.indexBounds.columnMinimum = IntegerNode(ibox.get("columnMinimum")).value();
			data3DHeader.indexBounds.columnMaximum = IntegerNode(ibox.get("columnMaximum")).value();
			data3DHeader.indexBounds.returnMinimum = IntegerNode(ibox.get("returnMinimum")).value();
			data3DHeader.indexBounds.returnMaximum = IntegerNode(ibox.get("returnMaximum")).value();

		}
// Get Cartesian bounding box to scan.
 
		if(scan.isDefined("cartesianBounds"))
		{
			StructureNode bbox(scan.get("cartesianBounds"));
			data3DHeader.cartesianBounds.xMinimum = FloatNode(bbox.get("xMinimum")).value();
			data3DHeader.cartesianBounds.xMaximum = FloatNode(bbox.get("xMaximum")).value();
			data3DHeader.cartesianBounds.yMinimum = FloatNode(bbox.get("yMinimum")).value();
			data3DHeader.cartesianBounds.yMaximum = FloatNode(bbox.get("yMaximum")).value();
			data3DHeader.cartesianBounds.zMinimum = FloatNode(bbox.get("zMinimum")).value();
			data3DHeader.cartesianBounds.zMaximum = FloatNode(bbox.get("zMaximum")).value();
		}

		if(scan.isDefined("sphericalBounds"))
		{
			StructureNode sbox(scan.get("sphericalBounds"));
			data3DHeader.sphericalBounds.rangeMinimum = FloatNode(sbox.get("rangeMinimum")).value();
			data3DHeader.sphericalBounds.rangeMaximum = FloatNode(sbox.get("rangeMaximum")).value();
			data3DHeader.sphericalBounds.elevationMinimum = FloatNode(sbox.get("elevationMinimum")).value();
			data3DHeader.sphericalBounds.elevationMaximum = FloatNode(sbox.get("elevationMaximum")).value();
			data3DHeader.sphericalBounds.azimuthStart = FloatNode(sbox.get("azimuthStart")).value();
			data3DHeader.sphericalBounds.azimuthEnd = FloatNode(sbox.get("azimuthEnd")).value();
		}

// Get pose structure for scan.

		if(scan.isDefined("pose"))
		{
			StructureNode pose(scan.get("pose"));
			StructureNode rotation(pose.get("rotation"));
			StructureNode translation(pose.get("translation"));

			data3DHeader.pose.rotation.w = FloatNode(rotation.get("w")).value();
			data3DHeader.pose.rotation.x = FloatNode(rotation.get("x")).value();
			data3DHeader.pose.rotation.y = FloatNode(rotation.get("y")).value();
			data3DHeader.pose.rotation.z = FloatNode(rotation.get("z")).value();
	  
			data3DHeader.pose.translation.x = FloatNode(translation.get("x")).value();
			data3DHeader.pose.translation.y = FloatNode(translation.get("y")).value();
			data3DHeader.pose.translation.z = FloatNode(translation.get("z")).value();
		}
 
// Get start/stop acquisition times to scan.

		if(scan.isDefined("acquisitionStart"))
		{
			StructureNode acquisitionStart(scan.get("acquisitionStart"));
			data3DHeader.acquisitionStart.dateTimeValue = 
				FloatNode(acquisitionStart.get("dateTimeValue")).value();
			data3DHeader.acquisitionStart.isGpsReferenced = (int32_t)
				IntegerNode(acquisitionStart.get("isAtomicClockReferenced")).value();
		}

		if(scan.isDefined("acquisitionEnd"))
		{
			StructureNode acquisitionEnd(scan.get("acquisitionEnd"));
			data3DHeader.acquisitionEnd.dateTimeValue = 
				FloatNode(acquisitionEnd.get("dateTimeValue")).value();
			data3DHeader.acquisitionEnd.isGpsReferenced = (int32_t)
				IntegerNode(acquisitionEnd.get("isAtomicClockReferenced")).value();
		}

// Get a prototype of datatypes that will be stored in points record.

		data3DHeader.pointFields.valid = proto.isDefined("valid");
		data3DHeader.pointFields.x = proto.isDefined("cartesianX");
		data3DHeader.pointFields.y = proto.isDefined("cartesianY");
		data3DHeader.pointFields.z = proto.isDefined("cartesianZ");
		data3DHeader.pointFields.range = proto.isDefined("sphericalRange");
		data3DHeader.pointFields.azimuth = proto.isDefined("spherialAzimuth");
		data3DHeader.pointFields.elevation = proto.isDefined("sphericalElevation");
		data3DHeader.pointFields.rowIndex = proto.isDefined("rowIndex");
		data3DHeader.pointFields.columnIndex = proto.isDefined("columnIndex");
		data3DHeader.pointFields.returnIndex = proto.isDefined("returnIndex");
		data3DHeader.pointFields.returnCount = proto.isDefined("returnCount");
		data3DHeader.pointFields.intensity = proto.isDefined("intensity");
		data3DHeader.pointFields.colorRed = proto.isDefined("colorRed");
		data3DHeader.pointFields.colorGreen = proto.isDefined("colorGreen");
		data3DHeader.pointFields.colorBlue = proto.isDefined("colorBlue");

		return true;
	}
	return false;
};

//! This function returns the size of the point data
bool	ReaderImpl :: GetData3DSizes(
	int32_t		dataIndex,	//!< image block index
	int64_t &	row,		//!< image row size
	int64_t &	column,		//!< image column size
	int64_t &	pointsSize,	//!< image total point count
	int64_t &	groupsSize	//!< image total number of groups
	)
{
	if(IsOpen())
	{
		if( (dataIndex < 0) || (dataIndex >= data3D_.childCount()))
			return false;

		StructureNode scan(data3D_.get(dataIndex));

		CompressedVectorNode points(scan.get("points"));
		pointsSize = points.childCount();

		if(scan.isDefined("pointGroupingSchemes"))
		{
			StructureNode pointGroupingSchemes(scan.get("pointGroupingSchemes"));
			StructureNode groupingByLine(pointGroupingSchemes.get("groupingByLine"));

			CompressedVectorNode groups(groupingByLine.get("groups"));
			groupsSize = groups.childCount();
		}
		else
			groupsSize = 0;

		if(scan.isDefined("indexBounds"))
		{
			StructureNode indexBounds(scan.get("indexBounds"));
			column = IntegerNode(indexBounds.get("columnMaximum")).value();
			row = IntegerNode(indexBounds.get("rowMaximum")).value();
		}
		else
		{
			StructureNode proto(points.prototype());

			if(proto.isDefined("columnIndex"))
				column = IntegerNode(proto.get("columnIndex")).maximum();
			else column = 0;

			if(proto.isDefined("rowIndex"))
				row = IntegerNode(proto.get("rowIndex")).maximum();
			else row = 0;
		}
		return true;
	}
	return false;
};

//! This funtion writes out the group data
bool	ReaderImpl :: ReadData3DGroupsData(
						int32_t		dataIndex,			//!< data block index given by the NewData3D
						int64_t		groupCount,			//!< size of each of the buffers given
						int64_t*	idElementValue,		//!< index for this group
						int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
						int64_t*	pointCount			//!< size of the groups given
						)								//!< \return Return true if sucessful, false otherwise
{
	if( (dataIndex < 0) || (dataIndex >= data3D_.childCount()))
		return false;

	StructureNode scan(data3D_.get(dataIndex));
	StructureNode pointGroupingSchemes(scan.get("pointGroupingSchemes"));
	StructureNode groupingByLine(pointGroupingSchemes.get("groupingByLine"));
	CompressedVectorNode groups(groupingByLine.get("groups"));

	vector<SourceDestBuffer> groupSDBuffers;
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "idElementValue",  idElementValue,   (unsigned) groupCount, true));
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "startPointIndex", startPointIndex,  (unsigned) groupCount, true));
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "pointCount",      pointCount,       (unsigned) groupCount, true));

	CompressedVectorReader reader = groups.reader(groupSDBuffers);
    reader.read();
    reader.close();

	return true;
};

//! This function returns the point data fields fetched in single call
//* All the non-NULL buffers in the call below have number of elements = count */

CompressedVectorReader	ReaderImpl :: SetUpData3DPointsData(
	int32_t		dataIndex,
	int64_t		count,
	int32_t*	valid,
	double*		x,
	double*		y,
	double*		z,
	double*		intensity,
	double*		colorRed,
	double*		colorGreen,
	double*		colorBlue,
	double*		range,
	double*		azimuth,
	double*		elevation,
	int64_t*	rowIndex,
	int64_t*	columnIndex,
	int64_t*	returnIndex,
	int64_t*	returnCount,
	double*		timeStamp
	)
{
	int64_t		readCount = 0;

	StructureNode scan(data3D_.get(dataIndex));
	CompressedVectorNode points(scan.get("points"));
	StructureNode proto(points.prototype());

	vector<SourceDestBuffer> destBuffers;
	if(proto.isDefined("cartesianX") && (x != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "cartesianX",  x,  (unsigned) count, true, true));
	if(proto.isDefined("cartesianY") && (y != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "cartesianY",  y,  (unsigned) count, true, true));
	if(proto.isDefined("cartesianZ") && (z != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "cartesianZ",  z,  (unsigned) count, true, true));
	if(proto.isDefined("sphericalRange") && (range != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "sphericalRange",  range,  (unsigned) count, true, true));
	if(proto.isDefined("spherialAzimuth") && (azimuth != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "spherialAzimuth",  azimuth,  (unsigned) count, true, true));
	if(proto.isDefined("sphericalElevation") && (elevation != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "sphericalElevation",  elevation,  (unsigned) count, true, true));
	if(proto.isDefined("valid") && (valid != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "valid",       valid,       (unsigned) count, true));
	if(proto.isDefined("rowIndex") && (rowIndex != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "rowIndex",    rowIndex,    (unsigned) count, true));
	if(proto.isDefined("columnIndex") && (columnIndex != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "columnIndex", columnIndex, (unsigned) count, true));
	if(proto.isDefined("returnIndex") && (returnIndex != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "returnIndex", returnIndex, (unsigned) count, true));
	if(proto.isDefined("returnCount") && (returnCount != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "returnCount", returnCount, (unsigned) count, true));
	if(proto.isDefined("timeStamp") && (timeStamp != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "timeStamp",   timeStamp,   (unsigned) count, true));
	if(proto.isDefined("intensity") && (intensity != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "intensity",   intensity,   (unsigned) count, true));
	if(proto.isDefined("colorRed") && (colorRed != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "colorRed",    colorRed,    (unsigned) count, true));
	if(proto.isDefined("colorGreen") && (colorGreen != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "colorGreen",  colorGreen,  (unsigned) count, true));
	if(proto.isDefined("colorBlue") && (colorBlue != NULL))
		destBuffers.push_back(SourceDestBuffer(imf_, "colorBlue",   colorBlue,   (unsigned) count, true));

	CompressedVectorReader reader = points.reader(destBuffers);

	return reader;
};

//! This function interrogate what fields (standardized and extensions) are available
bool	ReaderImpl :: GetData3DGeneralFieldsAvailable(
	int32_t					dataIndex,
	std::vector<ustring>&	fieldsAvailable)
{
	return false;
};

int64_t	ReaderImpl :: GetData3DGeneralPoints(
	int32_t				dataIndex,
	int64_t				startPointIndex,
	int64_t				pointCount,
	bool*				valid,
	vector<ustring>&	numericFieldNames,
	vector<double*>&	numericBuffers,
	vector<ustring>&	stringFieldNames,
	vector<ustring*>&	stringBuffers)
{
	return 0;
};
////////////////////////////////////////////////////////////////////
//
//	e57::Writer
//
//! This function is the constructor for the writer class
	WriterImpl::WriterImpl(
		const ustring & filePath,
		const ustring & coordinateMetadata)
	: imf_(filePath,"w")
	, root_(imf_.root())
	, data3D_(imf_,true)
	, cameraImages_(imf_,true)
{

// Set per-file properties.
/// Path names: "/formatName", "/majorVersion", "/minorVersion", "/coordinateMetadata"
	root_.set("formatName", StringNode(imf_, "ASTM E57 3D Imaging Data File"));

#if defined(_MSC_VER)
	GUID		guid;
	CoCreateGuid((GUID*)&guid);

	OLECHAR wbuffer[64];
	StringFromGUID2(guid,&wbuffer[0],64);

	char	fileGuid[64];
	wcstombs(fileGuid,wbuffer,64);
#else
	char	fileGuid[] = "{4179C162-49A8-4fba-ADC6-527543D26D86}";
#endif
	root_.set("guid", StringNode(imf_, fileGuid));

// Get ASTM version number supported by library, so can write it into file
	int astmMajor;
	int astmMinor;
	ustring libraryId;
	E57Utilities().getVersions(astmMajor, astmMinor, libraryId);

	root_.set("versionMajor", IntegerNode(imf_, astmMajor));
	root_.set("versionMinor", IntegerNode(imf_, astmMinor));

// Save a dummy string for coordinate system.
/// Really should be a valid WKT string identifying the coordinate reference system (CRS).
    root_.set("coordinateMetadata", StringNode(imf_, coordinateMetadata));

// Create creationDateTime structure
/// Path name: "/creationDateTime
    StructureNode creationDateTime = StructureNode(imf_);
	creationDateTime.set("dateTimeValue", FloatNode(imf_, 1234567890.)); //!!! convert time() to GPStime
	creationDateTime.set("isGpsReferenced", IntegerNode(imf_,0));
    root_.set("creationDateTime", creationDateTime);

	root_.set("data3D", data3D_);
	root_.set("cameraImages", cameraImages_);


};
//! This function is the destructor for the writer class
	WriterImpl::~WriterImpl(void)
{
	if(IsOpen())
		Close();
};
//! This function returns true if the file is open
bool	WriterImpl :: IsOpen(void)
{
	if(imf_.isOpen())
		return true;
	return false;
};

//! This function closes the file
bool	WriterImpl :: Close(void)
{
	if(IsOpen())
	{
		imf_.close();
		return true;
	}
	return false;
};

////////////////////////////////////////////////////////////////////
//
//	Camera Image picture data
//

//! This function sets up the cameraImages header and positions the cursor
//* The user needs to config a CameraImage structure with all the camera information before making this call. */
int32_t	WriterImpl :: NewCameraImage( 
	CameraImage &	cameraImageHeader	//!< pointer to the CameraImage structure to receive the picture information
	)						//!< /return Returns the cameraImage index
{
	int32_t pos = -1;

	StructureNode image = StructureNode(imf_);
	cameraImages_.append(image);
	pos = (int32_t) cameraImages_.childCount() - 1;

	image.set("guid", StringNode(imf_, cameraImageHeader.guid));
	image.set("name", StringNode(imf_, cameraImageHeader.name));
	image.set("description", StringNode(imf_, cameraImageHeader.description));

// Add various sensor and version strings to image.

	image.set("sensorVendor",           StringNode(imf_, cameraImageHeader.sensorVendor));
	image.set("sensorModel",            StringNode(imf_, cameraImageHeader.sensorModel));
	image.set("sensorSerialNumber",     StringNode(imf_, cameraImageHeader.sensorSerialNumber));

	image.set("associatedData3DGuid", StringNode(imf_, cameraImageHeader.associatedData3DGuid));

	StructureNode acquisitionDateTime = StructureNode(imf_);
    image.set("acquisitionDateTime", acquisitionDateTime);
	acquisitionDateTime.set("dateTimeValue",
		FloatNode(imf_, cameraImageHeader.acquisitionDateTime.dateTimeValue));
	acquisitionDateTime.set("isAtomicClockReferenced",
		IntegerNode(imf_, cameraImageHeader.acquisitionDateTime.isGpsReferenced));

// Create pose structure for image.

    StructureNode pose = StructureNode(imf_);
    image.set("pose", pose);

    StructureNode rotation = StructureNode(imf_);
    pose.set("rotation", rotation);
	rotation.set("w", FloatNode(imf_, cameraImageHeader.pose.rotation.w));
    rotation.set("x", FloatNode(imf_, cameraImageHeader.pose.rotation.x));
    rotation.set("y", FloatNode(imf_, cameraImageHeader.pose.rotation.y));
    rotation.set("z", FloatNode(imf_, cameraImageHeader.pose.rotation.z));
    StructureNode translation = StructureNode(imf_);
    pose.set("translation", translation);
	translation.set("x", FloatNode(imf_, cameraImageHeader.pose.translation.x));
    translation.set("y", FloatNode(imf_, cameraImageHeader.pose.translation.y));
    translation.set("z", FloatNode(imf_, cameraImageHeader.pose.translation.z));

	if( cameraImageHeader.visualReferenceRepresentation.jpegImage ||
		cameraImageHeader.visualReferenceRepresentation.pngImage)
	{
		StructureNode visualReferenceRepresentation = StructureNode(imf_);
		image.set("visualReferenceRepresentation", visualReferenceRepresentation);

		if( cameraImageHeader.visualReferenceRepresentation.jpegImage)
			visualReferenceRepresentation.set("jpegImage",
				BlobNode(imf_,cameraImageHeader.visualReferenceRepresentation.jpegImage));
		else if( cameraImageHeader.visualReferenceRepresentation.pngImage)
			visualReferenceRepresentation.set("pngImage",
				BlobNode(imf_,cameraImageHeader.visualReferenceRepresentation.pngImage));
		if( cameraImageHeader.visualReferenceRepresentation.imageMask)
			visualReferenceRepresentation.set("imageMask",
				BlobNode(imf_,cameraImageHeader.visualReferenceRepresentation.imageMask));
	}
	else if( cameraImageHeader.pinholeRepresentation.jpegImage ||
		cameraImageHeader.pinholeRepresentation.pngImage)
	{
		StructureNode pinholeRepresentation = StructureNode(imf_);
		image.set("pinholeRepresentation", pinholeRepresentation);

		if( cameraImageHeader.pinholeRepresentation.jpegImage)
			pinholeRepresentation.set("jpegImage",
				BlobNode(imf_,cameraImageHeader.pinholeRepresentation.jpegImage));
		else if( cameraImageHeader.pinholeRepresentation.pngImage)
			pinholeRepresentation.set("pngImage",
				BlobNode(imf_,cameraImageHeader.pinholeRepresentation.pngImage));
		if( cameraImageHeader.pinholeRepresentation.imageMask)
			pinholeRepresentation.set("imageMask",
				BlobNode(imf_,cameraImageHeader.pinholeRepresentation.imageMask));

		pinholeRepresentation.set("focalLength", 
			FloatNode(imf_, cameraImageHeader.pinholeRepresentation.focalLength));
		pinholeRepresentation.set("imageHeight", 
			IntegerNode(imf_, cameraImageHeader.pinholeRepresentation.imageHeight));
		pinholeRepresentation.set("imageWidth", 
			IntegerNode(imf_, cameraImageHeader.pinholeRepresentation.imageWidth));
		pinholeRepresentation.set("pixelHeight", 
			FloatNode(imf_, cameraImageHeader.pinholeRepresentation.pixelHeight));
		pinholeRepresentation.set("pixelWidth", 
			FloatNode(imf_, cameraImageHeader.pinholeRepresentation.pixelWidth));
		pinholeRepresentation.set("principalPointX", 
			FloatNode(imf_, cameraImageHeader.pinholeRepresentation.principalPointX));
		pinholeRepresentation.set("principalPointY", 
			FloatNode(imf_, cameraImageHeader.pinholeRepresentation.principalPointY));
	}
	else if( cameraImageHeader.sphericalRepresentation.jpegImage ||
		cameraImageHeader.sphericalRepresentation.pngImage)
	{
		StructureNode sphericalRepresentation = StructureNode(imf_);
		image.set("sphericalRepresentation", sphericalRepresentation);

		if( cameraImageHeader.sphericalRepresentation.jpegImage)
			sphericalRepresentation.set("jpegImage",
				BlobNode(imf_,cameraImageHeader.sphericalRepresentation.jpegImage));
		else if( cameraImageHeader.sphericalRepresentation.pngImage)
			sphericalRepresentation.set("pngImage",
				BlobNode(imf_,cameraImageHeader.sphericalRepresentation.pngImage));
		if( cameraImageHeader.sphericalRepresentation.imageMask)
			sphericalRepresentation.set("imageMask",
				BlobNode(imf_,cameraImageHeader.sphericalRepresentation.imageMask));

		sphericalRepresentation.set("imageHeight", 
			IntegerNode(imf_, cameraImageHeader.sphericalRepresentation.imageHeight));
		sphericalRepresentation.set("imageWidth", 
			IntegerNode(imf_, cameraImageHeader.sphericalRepresentation.imageWidth));
		sphericalRepresentation.set("pixelHeight", 
			FloatNode(imf_, cameraImageHeader.sphericalRepresentation.pixelHeight));
		sphericalRepresentation.set("pixelWidth", 
			FloatNode(imf_, cameraImageHeader.sphericalRepresentation.pixelWidth));
		sphericalRepresentation.set("azimuthStart", 
			FloatNode(imf_, cameraImageHeader.sphericalRepresentation.azimuthStart));
		sphericalRepresentation.set("elevationStart", 
			FloatNode(imf_, cameraImageHeader.sphericalRepresentation.elevationStart));
	}
	else if( cameraImageHeader.cylindricalRepresentation.jpegImage ||
		cameraImageHeader.cylindricalRepresentation.pngImage)
	{
		StructureNode cylindricalRepresentation = StructureNode(imf_);
		image.set("cylindricalRepresentation", cylindricalRepresentation);

		if( cameraImageHeader.cylindricalRepresentation.jpegImage)
			cylindricalRepresentation.set("jpegImage",
				BlobNode(imf_,cameraImageHeader.cylindricalRepresentation.jpegImage));
		else if( cameraImageHeader.cylindricalRepresentation.pngImage)
			cylindricalRepresentation.set("pngImage",
				BlobNode(imf_,cameraImageHeader.cylindricalRepresentation.pngImage));
		if( cameraImageHeader.cylindricalRepresentation.imageMask)
			cylindricalRepresentation.set("imageMask",
				BlobNode(imf_,cameraImageHeader.cylindricalRepresentation.imageMask));

		cylindricalRepresentation.set("imageHeight", 
			IntegerNode(imf_, cameraImageHeader.cylindricalRepresentation.imageHeight));
		cylindricalRepresentation.set("imageWidth", 
			IntegerNode(imf_, cameraImageHeader.cylindricalRepresentation.imageWidth));
		cylindricalRepresentation.set("pixelHeight", 
			FloatNode(imf_, cameraImageHeader.cylindricalRepresentation.pixelHeight));
		cylindricalRepresentation.set("pixelWidth", 
			FloatNode(imf_, cameraImageHeader.cylindricalRepresentation.pixelWidth));
		cylindricalRepresentation.set("azimuthStart", 
			FloatNode(imf_, cameraImageHeader.cylindricalRepresentation.azimuthStart));
		cylindricalRepresentation.set("principalPointY", 
			FloatNode(imf_, cameraImageHeader.cylindricalRepresentation.principalPointY));
		cylindricalRepresentation.set("radius", 
			FloatNode(imf_, cameraImageHeader.cylindricalRepresentation.radius));
	}
	return pos;
};

//! This function writes the block
int64_t	WriterImpl :: WriteCameraImageData(
	int32_t		imageIndex,	//!< picture block index
	void *		pBuffer,	//!< pointer the buffer
	int64_t		start,		//!< position in the block to start writing
	int64_t		count		//!< size of desired chuck or buffer size
	)						//!< /return Returns the number of bytes written
{
	if( (imageIndex < 0) || (imageIndex >= cameraImages_.childCount()))
		return 0;

	StructureNode image(cameraImages_.get(imageIndex));

	if(image.isDefined("visualReferenceRepresentation"))
	{
		StructureNode visualReferenceRepresentation(image.get("visualReferenceRepresentation"));
		if(visualReferenceRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(visualReferenceRepresentation.get("jpegImage"));
			jpegImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(visualReferenceRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(visualReferenceRepresentation.get("pngImage"));
			pngImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(visualReferenceRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(visualReferenceRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("pinholeRepresentation"))
	{
		StructureNode pinholeRepresentation(image.get("pinholeRepresentation"));
		if(pinholeRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(pinholeRepresentation.get("jpegImage"));
			jpegImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(pinholeRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(pinholeRepresentation.get("pngImage"));
			pngImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(pinholeRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(pinholeRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("sphericalRepresentation"))
	{
		StructureNode sphericalRepresentation(image.get("sphericalRepresentation"));
		if(sphericalRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(sphericalRepresentation.get("jpegImage"));
			jpegImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(sphericalRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(sphericalRepresentation.get("pngImage"));
			pngImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(sphericalRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(sphericalRepresentation.get("imageMask"));
//			}
	}
	else if(image.isDefined("cylindricalRepresentation"))
	{
		StructureNode cylindricalRepresentation(image.get("cylindricalRepresentation"));
		if(cylindricalRepresentation.isDefined("jpegImage"))
		{
			BlobNode jpegImage(cylindricalRepresentation.get("jpegImage"));
			jpegImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
		else if(cylindricalRepresentation.isDefined("pngImage"))
		{
			BlobNode pngImage(cylindricalRepresentation.get("pngImage"));
			pngImage.write((uint8_t*) pBuffer, start, (size_t) count);
		}
//			if(cylindricalRepresentation.isDefined("imageMask"))
//			{
//				BlobNode imageMask(cylindricalRepresentation.get("imageMask"));
//			}
	}
	return count;
};
//! This function closes the CameraImage block
bool	WriterImpl :: CloseCameraImage(
	int32_t		imageIndex	//!< picture block index given by the NewCameraImage
		)					//!< /return Returns true if successful, false otherwise
{
	return false;
}
//! This function sets up the Data3D header and positions the cursor for the binary data
//* The user needs to config a Data3D structure with all the scanning information before making this call. */

int32_t	WriterImpl :: NewData3D( 
	Data3D &	data3DHeader //!< pointer to the Data3D structure to receive the image information
	)	//!< /return Returns the index of the new scan.
{
	int32_t pos = -1;

	int32_t row = (int32_t) data3DHeader.indexBounds.rowMaximum;
	int32_t col = (int32_t) data3DHeader.indexBounds.columnMaximum;

	StructureNode scan = StructureNode(imf_);
	data3D_.append(scan);
	pos = (int32_t) data3D_.childCount() - 1;

	scan.set("guid", StringNode(imf_, data3DHeader.guid));
	scan.set("name", StringNode(imf_, data3DHeader.name));
	scan.set("description", StringNode(imf_, data3DHeader.description));

// Add various sensor and version strings to scan.
/// Path names: "/data3D/0/sensorVendor", etc...
	scan.set("sensorVendor",           StringNode(imf_, data3DHeader.sensorVendor));
	scan.set("sensorModel",            StringNode(imf_, data3DHeader.sensorModel));
	scan.set("sensorSerialNumber",     StringNode(imf_, data3DHeader.sensorSerialNumber));
	scan.set("sensorHardwareVersion",  StringNode(imf_, data3DHeader.sensorHardwareVersion));
	scan.set("sensorSoftwareVersion",  StringNode(imf_, data3DHeader.sensorSoftwareVersion));
	scan.set("sensorFirmwareVersion",  StringNode(imf_, data3DHeader.sensorFirmwareVersion));

// Add temp/humidity to scan.
/// Path names: "/data3D/0/temperature", etc...
	scan.set("temperature",      FloatNode(imf_, data3DHeader.temperature));
	scan.set("relativeHumidity", FloatNode(imf_, data3DHeader.relativeHumidity));
	scan.set("atmosphericPressure", FloatNode(imf_, data3DHeader.atmosphericPressure));

    StructureNode ibox = StructureNode(imf_);
	ibox.set("rowMinimum", IntegerNode(imf_, data3DHeader.indexBounds.rowMinimum));
	ibox.set("rowMaximum", IntegerNode(imf_, data3DHeader.indexBounds.rowMaximum));
	ibox.set("columnMinimum", IntegerNode(imf_, data3DHeader.indexBounds.columnMinimum));
	ibox.set("columnMaximum", IntegerNode(imf_, data3DHeader.indexBounds.columnMaximum));
	ibox.set("returnMinimum", IntegerNode(imf_, data3DHeader.indexBounds.returnMinimum));
	ibox.set("returnMaximum", IntegerNode(imf_, data3DHeader.indexBounds.returnMaximum));
    scan.set("indexBounds", ibox);

// Add Cartesian bounding box to scan.
/// Path names: "/data3D/0/cartesianBounds/xMinimum", etc...
    StructureNode bbox = StructureNode(imf_);
	bbox.set("xMinimum", FloatNode(imf_, data3DHeader.cartesianBounds.xMinimum));
	bbox.set("xMaximum", FloatNode(imf_, data3DHeader.cartesianBounds.xMaximum));
	bbox.set("yMinimum", FloatNode(imf_, data3DHeader.cartesianBounds.yMinimum));
	bbox.set("yMaximum", FloatNode(imf_, data3DHeader.cartesianBounds.yMaximum));
	bbox.set("zMinimum", FloatNode(imf_, data3DHeader.cartesianBounds.zMinimum));
	bbox.set("zMaximum", FloatNode(imf_, data3DHeader.cartesianBounds.zMaximum));
    scan.set("cartesianBounds", bbox);

	StructureNode sbox = StructureNode(imf_);
	sbox.set("rangeMinimum", FloatNode(imf_, data3DHeader.sphericalBounds.rangeMinimum));
	sbox.set("rangeMaximum", FloatNode(imf_, data3DHeader.sphericalBounds.rangeMaximum));
	sbox.set("elevationMinimum", FloatNode(imf_, data3DHeader.sphericalBounds.elevationMinimum));
	sbox.set("elevationMaximum", FloatNode(imf_, data3DHeader.sphericalBounds.elevationMaximum));
	sbox.set("azimuthStart", FloatNode(imf_, data3DHeader.sphericalBounds.azimuthStart));
	sbox.set("azimuthEnd", FloatNode(imf_, data3DHeader.sphericalBounds.azimuthEnd));
	scan.set("sphericalBounds", sbox);
// Create pose structure for scan.
/// Path names: "/data3D/0/pose/rotation/w", etc...
///             "/data3D/0/pose/translation/x", etc...
    StructureNode pose = StructureNode(imf_);
    scan.set("pose", pose);
    StructureNode rotation = StructureNode(imf_);
    pose.set("rotation", rotation);
	rotation.set("w", FloatNode(imf_, data3DHeader.pose.rotation.w));
    rotation.set("x", FloatNode(imf_, data3DHeader.pose.rotation.x));
    rotation.set("y", FloatNode(imf_, data3DHeader.pose.rotation.y));
    rotation.set("z", FloatNode(imf_, data3DHeader.pose.rotation.z));
    StructureNode translation = StructureNode(imf_);
    pose.set("translation", translation);
	translation.set("x", FloatNode(imf_, data3DHeader.pose.translation.x));
    translation.set("y", FloatNode(imf_, data3DHeader.pose.translation.y));
    translation.set("z", FloatNode(imf_, data3DHeader.pose.translation.z));

// Add start/stop acquisition times to scan.
/// Path names: "/data3D/0/acquisitionStart/dateTimeValue",
///             "/data3D/0/acquisitionEnd/dateTimeValue"
    StructureNode acquisitionStart = StructureNode(imf_);
    scan.set("acquisitionStart", acquisitionStart);
	acquisitionStart.set("dateTimeValue",
		FloatNode(imf_, data3DHeader.acquisitionStart.dateTimeValue));
	acquisitionStart.set("isAtomicClockReferenced",
		IntegerNode(imf_, data3DHeader.acquisitionStart.isGpsReferenced));

    StructureNode acquisitionEnd = StructureNode(imf_);
    scan.set("acquisitionEnd", acquisitionEnd);
	acquisitionEnd.set("dateTimeValue",
		FloatNode(imf_, data3DHeader.acquisitionEnd.dateTimeValue));
	acquisitionEnd.set("isAtomicClockReferenced",
		IntegerNode(imf_, data3DHeader.acquisitionEnd.isGpsReferenced));

// Add grouping scheme area
    /// Path name: "/data3D/0/pointGroupingSchemes"
    StructureNode pointGroupingSchemes = StructureNode(imf_);
    scan.set("pointGroupingSchemes", pointGroupingSchemes);

    /// Add a line grouping scheme
    /// Path name: "/data3D/0/pointGroupingSchemes/groupingByLine"
    StructureNode groupingByLine = StructureNode(imf_);
    pointGroupingSchemes.set("groupingByLine", groupingByLine);

    /// Add idElementName to groupingByLine, specify a line is column oriented
    /// Path name: "/data3D/0/pointGroupingSchemes/groupingByLine/idElementName"
	groupingByLine.set("idElementName", StringNode(imf_,
		data3DHeader.pointGroupingSchemes.groupingByLine.idElementName));

	///			data3DHeader.pointGroupingSchemes.groupingByLine.idElementName));

// Make a prototype of datatypes that will be stored in LineGroupRecord.
    /// This prototype will be used in creating the groups CompressedVector.
    /// Will define path names like:
    ///     "/data3D/0/pointGroupingSchemes/groupingByLine/groups/0/idElementValue"
    StructureNode lineGroupProto = StructureNode(imf_);
    lineGroupProto.set("idElementValue",    IntegerNode(imf_, 0, 0, col));
    lineGroupProto.set("startPointIndex",   IntegerNode(imf_, 0, 0, row*col));
    lineGroupProto.set("pointCount",        IntegerNode(imf_, 0, 0, row));

   /// Make empty codecs vector for use in creating groups CompressedVector.
    /// If this vector is empty, it is assumed that all fields will use the BitPack codec.
    VectorNode lineGroupCodecs = VectorNode(imf_, true);

    /// Create CompressedVector for storing groups.  
    /// Path Name: "/data3D/0/pointGroupingSchemes/groupingByLine/groups".
    /// We use the prototype and empty codecs tree from above.
    /// The CompressedVector will be filled by code below.
    CompressedVectorNode groups = CompressedVectorNode(imf_, lineGroupProto, lineGroupCodecs);
    groupingByLine.set("groups", groups);

// Make a prototype of datatypes that will be stored in points record.
    /// This prototype will be used in creating the points CompressedVector.
    /// Using this proto in a CompressedVector will define path names like:
    ///      "/data3D/0/points/0/cartesianX"
    StructureNode proto = StructureNode(imf_);

	if(data3DHeader.pointFields.valid)
		proto.set("valid",       IntegerNode(imf_, 0, 0, 1));

	if(data3DHeader.pointFields.x)
		proto.set("cartesianX",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));
//			proto.set("cartesianX",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));
	if(data3DHeader.pointFields.y)
		proto.set("cartesianY",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));
//			proto.set("cartesianY",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));
	if(data3DHeader.pointFields.z)
		proto.set("cartesianZ",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));
//			proto.set("cartesianZ",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));

	if(data3DHeader.pointFields.range)
		proto.set("sphericalRange",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));
//			proto.set("sphericalRange",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));
	if(data3DHeader.pointFields.azimuth)
		proto.set("spherialAzimuth",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));
//			proto.set("spherialAzimuth",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));
	if(data3DHeader.pointFields.elevation)
		proto.set("sphericalElevation",  ScaledIntegerNode(imf_, 0, E57_INT16_MIN, E57_INT16_MAX, 0.001, 0));
//			proto.set("sphericalElevation",  FloatNode(imf_, 0., E57_SINGLE, E57_FLOAT_MIN, E57_FLOAT_MAX));

	if(data3DHeader.pointFields.rowIndex)
		proto.set("rowIndex",    IntegerNode(imf_, 0, 0, row));
	if(data3DHeader.pointFields.columnIndex)
		proto.set("columnIndex", IntegerNode(imf_, 0, 0, col));

	if(data3DHeader.pointFields.returnIndex)
		proto.set("returnIndex", IntegerNode(imf_, 0, 0, 0));
    if(data3DHeader.pointFields.returnCount)
		proto.set("returnCount", IntegerNode(imf_, 1, 1, 1));
	if(data3DHeader.pointFields.timeStamp)
		proto.set("timeStamp",   FloatNode(imf_, 0.0, E57_DOUBLE));

	if(data3DHeader.pointFields.intensity)
		proto.set("intensity",   FloatNode(imf_, 0.0, E57_SINGLE, 0.0, 1.0));
//			proto.set("intensity",   IntegerNode(imf_, 0, 0, 255));
	if(data3DHeader.pointFields.colorRed)
		proto.set("colorRed",    FloatNode(imf_, 0.0, E57_SINGLE, 0.0, 1.0));
//			proto.set("colorRed",   IntegerNode(imf_, 0, 0, 255));
	if(data3DHeader.pointFields.colorGreen)
		proto.set("colorGreen",  FloatNode(imf_, 0.0, E57_SINGLE, 0.0, 1.0));
//			proto.set("colorGreen",   IntegerNode(imf_, 0, 0, 255));
	if(data3DHeader.pointFields.colorBlue)
		proto.set("colorBlue",   FloatNode(imf_, 0.0, E57_SINGLE, 0.0, 1.0));
//			proto.set("colorBlue",   IntegerNode(imf_, 0, 0, 255));

//        proto.set("demo:extra2", StringNode(imf_));

// Make empty codecs vector for use in creating points CompressedVector.
    /// If this vector is empty, it is assumed that all fields will use the BitPack codec.
    VectorNode codecs = VectorNode(imf_, true);

// Create CompressedVector for storing points.  Path Name: "/data3D/0/points".
    /// We use the prototype and empty codecs tree from above.
    /// The CompressedVector will be filled by code below.
    CompressedVectorNode points = CompressedVectorNode(imf_, proto, codecs);
    scan.set("points", points);
	return pos;
};

CompressedVectorWriter	WriterImpl :: SetUpData3DPointsData(
	int32_t		dataIndex,
	int64_t		count,
	int32_t*	valid,
	double*		x,
	double*		y,
	double*		z,
	double*		intensity,
	double*		colorRed,
	double*		colorGreen,
	double*		colorBlue,
	double*		range,
	double*		azimuth,
	double*		elevation,
	int64_t*	rowIndex,
	int64_t*	columnIndex,
	int64_t*	returnIndex,
	int64_t*	returnCount,
	double*		timeStamp
	)
{
	StructureNode scan(data3D_.get(dataIndex));
	CompressedVectorNode points(scan.get("points"));
	StructureNode proto(points.prototype());

	vector<SourceDestBuffer> sourceBuffers;
	if(proto.isDefined("cartesianX") && (x != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "cartesianX",  x,  (unsigned) count, true, true));
	if(proto.isDefined("cartesianY") && (y != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "cartesianY",  y,  (unsigned) count, true, true));
	if(proto.isDefined("cartesianZ") && (z != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "cartesianZ",  z,  (unsigned) count, true, true));
	if(proto.isDefined("sphericalRange") && (range != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "sphericalRange",  range,  (unsigned) count, true, true));
	if(proto.isDefined("spherialAzimuth") && (azimuth != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "spherialAzimuth",  azimuth,  (unsigned) count, true, true));
	if(proto.isDefined("sphericalElevation") && (elevation != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "sphericalElevation",  elevation,  (unsigned) count, true, true));
	if(proto.isDefined("valid") && (valid != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "valid",       valid,       (unsigned) count, true));
	if(proto.isDefined("rowIndex") && (rowIndex != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "rowIndex",    rowIndex,    (unsigned) count, true));
	if(proto.isDefined("columnIndex") && (columnIndex != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "columnIndex", columnIndex, (unsigned) count, true));
	if(proto.isDefined("returnIndex") && (returnIndex != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "returnIndex", returnIndex, (unsigned) count, true));
	if(proto.isDefined("returnCount") && (returnCount != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "returnCount", returnCount, (unsigned) count, true));
	if(proto.isDefined("timeStamp") && (timeStamp != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "timeStamp",   timeStamp,   (unsigned) count, true));
	if(proto.isDefined("intensity") && (intensity != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "intensity",   intensity,   (unsigned) count, true));
	if(proto.isDefined("colorRed") && (colorRed != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "colorRed",    colorRed,    (unsigned) count, true));
	if(proto.isDefined("colorGreen") && (colorGreen != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "colorGreen",  colorGreen,  (unsigned) count, true));
	if(proto.isDefined("colorBlue") && (colorBlue != NULL))
		sourceBuffers.push_back(SourceDestBuffer(imf_, "colorBlue",   colorBlue,   (unsigned) count, true));

	CompressedVectorWriter writer = points.writer(sourceBuffers);

	return writer;
};
//! This funtion writes out the group data
bool	WriterImpl :: WriteData3DGroupsData(
						int32_t		dataIndex,			//!< data block index given by the NewData3D
						int64_t*	idElementValue,		//!< index for this group
						int64_t*	startPointIndex,	//!< Starting index in to the "points" data vector for the groups
						int64_t*	pointCount,			//!< size of each of the groups given
						int32_t		count				//!< size of each of the buffers given
						)								//!< \return Return true if sucessful, false otherwise
{

	if( (dataIndex < 0) || (dataIndex >= data3D_.childCount()))
		return false;

	StructureNode scan(data3D_.get(dataIndex));
	StructureNode pointGroupingSchemes(scan.get("pointGroupingSchemes"));
	StructureNode groupingByLine(pointGroupingSchemes.get("groupingByLine"));
	CompressedVectorNode groups(groupingByLine.get("groups"));

	vector<SourceDestBuffer> groupSDBuffers;
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "idElementValue",  idElementValue,   count, true));
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "startPointIndex", startPointIndex,  count, true));
    groupSDBuffers.push_back(SourceDestBuffer(imf_, "pointCount",      pointCount,       count, true));

	CompressedVectorWriter writer = groups.writer(groupSDBuffers);
    writer.write(count);
    writer.close();

	return true;
};

//! This function sets the extensions field that will be available
bool	WriterImpl :: SetData3DGeneralFieldsAvailable(
	int32_t					dataIndex,
	std::vector<ustring>&	fieldsAvailable)
{
	return false;
};

int64_t	WriterImpl :: WriteData3DGeneralPoints(
	int32_t				dataIndex,
	int64_t				startPointIndex,
	int64_t				pointCount,
	bool*				valid,
	vector<ustring>&	numericFieldNames,
	vector<double*>&	numericBuffers,
	vector<ustring>&	stringFieldNames,
	vector<ustring*>&	stringBuffers)
{
	return 0;
};



