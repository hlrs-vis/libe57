/*
 * E57Foundation.cpp - implementation of public functions of the E57 format
 *   reference implementation.
 *
 * Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
//! \file E57Foundation.cpp

#include "E57FoundationImpl.h"
using namespace e57;
using namespace std;
using namespace std::tr1;

//=====================================================================================
/*================*/ /*!
\class e57::Node
\brief   some Node doc???
\details some more Node doc???
common state
base class, polymorphism
converted to derived class in type-safe way
node in heirarchical tree 
list of terminal and non-terminal node types
pathName and elementName
conceptually the elementName is associate with parent-child link.  root node has no elementName
rooted in ImageFile or not
associated with ImageFile
type equivalence
late binding (DLL)


parent of node is non-terminal and has node as its child
all nodes in tree are associated with same ImageFile
terminal nodes can have no children
field names of non-terminal node children are unique with that set.
Homogeneous Vector and CV children must be type equivalent.
Except for the root node, the parent will never change.
relationship between pathName and elementName
field name of a root node

Structure children are unordered
Vector (CV) children are ordered.
CV
only a root node can be attached as child


\invariant ???
\see     ??? 
*/ //================

/*================*/ /*!
\brief   Return the type of the node.
\details ???
\pre     ??? Associated ImageFile must be open.
\post    ??? No visible state is modified.
\return  ??? The type of the node.
\throw   ??? file is closed
\see     See NodeType for list of defined node types.
*/ //================
NodeType Node::type()                       {return(impl_->type());}

/*================*/ /*!
\brief   Is this a root node.
\details ???
\pre     ??? Associated ImageFile must be open.
\post    ??? No visible state is modified.
\return  ??? The node type
\throw   ??? file is closed
\see     ??? 
*/ //================
bool Node::isRoot()                         {return(impl_->isRoot());}

/*================*/ /*!
\brief   Return parent node of this node, or self if this is the root node.
\details ???
\pre     ??? Associated ImageFile must be open.
\post    ??? No visible state is modified.
\return  ??? The node type
\throw   ??? file is closed
\see     ??? 
*/ //================
Node Node::parent()                         {return(Node(impl_->parent()));}

/*================*/ /*!
\brief   Get absolute pathname of this node.
\details ???
\pre     ??? Associated ImageFile must be open.
\post    ??? No visible state is modified.
\return  ??? The node type
\throw   ??? file is closed
\see     ??? 
*/ //================
ustring Node::pathName()                    {return(impl_->pathName());}

/*================*/ /*!
\brief   Get field name of this node.
\details ???
\pre     ??? Associated ImageFile must be open.
\post    ??? No visible state is modified.
\return  ??? The node type
\throw   ??? file is closed
\see     ??? 
*/ //================
ustring Node::elementName()                   {return(impl_->elementName());}

/*================*/ /*!
\brief   Diagnostic function to print state of object and children to output stream in indented format.
\param   [in] indent number of spaces to indent all the printed lines of this object.
\param   [in] os stream to print on
\details ???
\pre     ??? 
\post    ??? No visible state is modified.
\return  ???
\throw   ???
\see     ??? 
*/ //================
#ifdef E57_DEBUG
void Node::dump(int indent, std::ostream& os)    {impl_->dump(indent, os);}
#else
void Node::dump(int indent, std::ostream& os)    {}
#endif

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
Node::Node(shared_ptr<NodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::StructureNode
\brief   some StructureNode doc???
\details some more StructureNode doc???
\invariant ???
\see     ??? 
*/

/*================*/ /*!
\brief   Create empty new Structure node.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StructureNode::StructureNode(ImageFile imf)
: impl_(new StructureNodeImpl(imf.impl()))
{}

//! \copydoc Node::type()
NodeType StructureNode::type()                              {return(impl_->type());}

//! \copydoc Node::isRoot()
bool StructureNode::isRoot()                                {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node StructureNode::parent()                                {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring StructureNode::pathName()                           {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring StructureNode::elementName()                          {return(impl_->elementName());}

/*================*/ /*!
\brief   Return number of chidren in the Structure
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t StructureNode::childCount()                         {return(impl_->childCount());}

/*================*/ /*!
\brief   Is the given pathName defined relative to this node.
\param   [in] pathName
\details ??? The pathName may be relative to this node, or absolute (starting with a "/").
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool StructureNode::isDefined(const ustring& pathName)      {return(impl_->isDefined(pathName));}

/*================*/ /*!
\brief   Get a child element by index.
\param   [in] index ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   E57Error(E57_ERROR_INDEX_OUT_OF_BOUNDS)
\see     ??? 
*/ //================
Node StructureNode::get(int64_t index)                      {return(Node(impl_->get(index)));}

/*================*/ /*!
\brief   Get a child by path name.
\param   [in] pathName ???
\details ??? The pathName may be relative to this node, or absolute (starting with a "/").
The pathName may be several levels deep (e.g. "translation/x").
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
Node StructureNode::get(const ustring& pathName)            {return(Node(impl_->get(pathName)));}

/*================*/ /*!
\brief   Add a new child at a given path
\param   [in] pathName ???
\param   [in] n ???
\param   [in] autoPathCreate ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void StructureNode::set(const ustring& pathName, Node n, bool autoPathCreate)   {impl_->set(pathName, n.impl(), autoPathCreate);}

/*================*/ /*!
\brief   Append a new child with a unique numeric element name
\param   [in] n ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void StructureNode::append(Node n)                          {impl_->append(n.impl());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void StructureNode::dump(int indent, std::ostream& os)      {impl_->dump(indent, os);}
#else
void StructureNode::dump(int indent, std::ostream& os)      {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StructureNode::operator Node()
{
    /// Implicitly upcast from shared_ptr<StructureNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a Structure handle.
\param   [in] n ??? The generic handle to a Structure object.
\details ???  The handle n must be for a Structure node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StructureNode::StructureNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<StructureNodeImpl>
    shared_ptr<StructureNodeImpl> ni(dynamic_pointer_cast<StructureNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
StructureNode::StructureNode(std::tr1::weak_ptr<ImageFileImpl> fileParent)
: impl_(new StructureNodeImpl(fileParent))
{}

StructureNode::StructureNode(shared_ptr<StructureNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::VectorNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     ??? 
*/

/*================*/ /*!
\brief   Create a new empty Vector node.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] allowHeteroChildren ??? true if child elements do not have to be same types.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
VectorNode::VectorNode(ImageFile imf, bool allowHeteroChildren)
: impl_(new VectorNodeImpl(imf.impl(), allowHeteroChildren))
{}

//! \copydoc Node::type()
NodeType VectorNode::type()                             {return(impl_->type());}

//! \copydoc Node::isRoot()
bool VectorNode::isRoot()                               {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node VectorNode::parent()                               {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring VectorNode::pathName()                          {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring VectorNode::elementName()                         {return(impl_->elementName());}

/*================*/ /*!
\brief   ??? Can child elements be different types?
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool VectorNode::allowHeteroChildren()                  {return(impl_->allowHeteroChildren());}

/*================*/ /*!
\brief   ??? Number of child elements in Vector
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t VectorNode::childCount()                        {return(impl_->childCount());}

/*================*/ /*!
\brief   ??? Is the given pathName defined relative to this node?
\param   [in] pathName ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool VectorNode::isDefined(const ustring& pathName)     {return(impl_->isDefined(pathName));}

/*================*/ /*!
\brief   ??? Get a child element by index.
\param   [in] index ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
Node VectorNode::get(int64_t index)                     {return(Node(impl_->get(index)));}

/*================*/ /*!
\brief   ???  Append child element to end of Vector
\param   [in] n ??? The node to append.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void VectorNode::append(Node n)                         {impl_->append(n.impl());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void VectorNode::dump(int indent, std::ostream& os)          {impl_->dump(indent, os);}
#else
void VectorNode::dump(int indent, std::ostream& os)          {}
#endif


/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
VectorNode::operator Node()
{
    /// Implicitly upcast from shared_ptr<VectorNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a Vector handle.
\param   [in] n ??? The generic handle to a Vector object.
\details ???  The handle n must be for a Vector node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
VectorNode::VectorNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<VectorNodeImpl>
    shared_ptr<VectorNodeImpl> ni(dynamic_pointer_cast<VectorNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
Node VectorNode::get(const ustring& pathName)           {return(Node(impl_->get(pathName)));}

void VectorNode::set(const ustring& pathName, Node n, bool autoPathCreate)  {/*???impl_->set(pathName, n.impl());*/} //$$$ huh?

VectorNode::VectorNode(shared_ptr<VectorNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::SourceDestBuffer
\brief   some doc???
\details some more doc???
\invariant ???
\see     ??? 
*/

/*================*/ /*!
\brief   Designate buffers to transfer data to/from a CompressedVector as a block.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] pathName ???
\param   [in] b ???
\param   [in] capacity ???
\param   [in] doConversion ???
\param   [in] doScaling ???
\param   [in] stride ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, int8_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, uint8_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, int16_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, uint16_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, int32_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, uint32_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, int64_t* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, bool* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, float* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

//! \copydoc SourceDestBuffer::SourceDestBuffer(ImageFile, ustring, int8_t*, unsigned, bool, bool, size_t)
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, double* b, unsigned capacity, bool doConversion, bool doScaling, size_t stride)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b, capacity, doConversion, doScaling, stride))
{}

/*================*/ /*!
\brief   Designate vector of strings to transfer data to/from a CompressedVector as a block.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] pathName ???
\param   [in] b ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
SourceDestBuffer::SourceDestBuffer(ImageFile imf, ustring pathName, std::vector<ustring>* b)
: impl_(new SourceDestBufferImpl(imf.impl(), pathName, b))
{}

/*================*/ /*!
\brief   ??? Get pathName of element in prototype that buffer will send/receive data
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ustring     SourceDestBuffer::pathName()        {return(impl_->pathName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
MemoryRep   SourceDestBuffer::elementType()     {return(impl_->elementType());};

/*================*/ /*!
\brief   ??? Get number of elements in buffer.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
unsigned    SourceDestBuffer::capacity()        {return(impl_->capacity());}

/*================*/ /*!
\brief   ??? Will conversions be performed to match the type of element in buffer.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool        SourceDestBuffer::doConversion()    {return(impl_->doConversion());}

/*================*/ /*!
\brief   ??? Will scaling be performed for ScaledInteger transfers.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool        SourceDestBuffer::doScaling()       {return(impl_->doScaling());}

/*================*/ /*!
\brief   ??? Get number of bytes between consecutive elements in buffer
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
size_t      SourceDestBuffer::stride()          {return(impl_->stride());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void SourceDestBuffer::dump(int indent, std::ostream& os)            {impl_->dump(indent, os);}
#else
void SourceDestBuffer::dump(int indent, std::ostream& os)            {}
#endif

//=====================================================================================
/*! \class e57::CompressedVectorReader
\brief   some doc???
\details some more doc???
\invariant ???
\see     ??? 
*/

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
CompressedVectorReader::CompressedVectorReader(shared_ptr<CompressedVectorReaderImpl> ni)
: impl_(ni)
{}
//! \endcond

/*================*/ /*!
\brief   ??? Request transfer of block of data from CompressedVector into previously designated buffers.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
unsigned CompressedVectorReader::read()
{
    return(impl_->read());
}

/*================*/ /*!
\brief   ??? Request transfer of block of data from CompressedVector into given buffers.
\param   [in] dbufs ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
unsigned CompressedVectorReader::read(std::vector<SourceDestBuffer>& dbufs)
{
    return(impl_->read(dbufs));
}

/*================*/ /*!
\brief   ??? Set record number where next read will start.
\param   [in] recordNumber ???
\details ??? Not yet implemented!!!
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void CompressedVectorReader::seek(uint64_t recordNumber)
{
    impl_->seek(recordNumber);
}

/*================*/ /*!
\brief   ??? End the read operation.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void CompressedVectorReader::close()
{
    impl_->close();
}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void CompressedVectorReader::dump(int indent, std::ostream& os)      {impl_->dump(indent, os);}
#else
void CompressedVectorReader::dump(int indent, std::ostream& os)      {}
#endif

//=====================================================================================
/*! \class e57::CompressedVectorWriter
\brief   some doc???
\details some more doc???
\invariant ???
\see     ??? 
*/

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
CompressedVectorWriter::CompressedVectorWriter(shared_ptr<CompressedVectorWriterImpl> ni)
: impl_(ni)
{}
//! \endcond

/*================*/ /*!
\brief   ??? Request transfer of block of data from previously designated buffers into CompressedVector.
\param   [in] elementCount ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void CompressedVectorWriter::write(unsigned elementCount)
{
    impl_->write(elementCount);
}

/*================*/ /*!
\brief   ??? Request transfer of block of data from given buffers into CompressedVector.
\param   [in] sbufs ???
\param   [in] elementCount ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void CompressedVectorWriter::write(std::vector<SourceDestBuffer>& sbufs, unsigned elementCount)
{
    impl_->write(sbufs, elementCount);
}

/*================*/ /*!
\brief   ??? End the read operation.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void CompressedVectorWriter::close()
{
    impl_->close();
}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void CompressedVectorWriter::dump(int indent, std::ostream& os)      {impl_->dump(indent, os);}
#else
void CompressedVectorWriter::dump(int indent, std::ostream& os)      {}
#endif

//=====================================================================================
/*! \class e57::CompressedVectorNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     ??? 
*/

/*================*/ /*!
\brief   ??? Create a CompressedVector node.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] prototype ???
\param   [in] codecs ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
CompressedVectorNode::CompressedVectorNode(ImageFile imf, Node prototype, Node codecs)
: impl_(new CompressedVectorNodeImpl(imf.impl()))
{
    /// Because of shared_ptr quirks, can't set prototype,codecs in CompressedVectorNodeImpl(), so set it afterwards ???true?
    impl_->setPrototype(prototype.impl());
    impl_->setCodecs(codecs.impl());
}

//! \copydoc Node::type()
NodeType CompressedVectorNode::type()                           {return(impl_->type());}

//! \copydoc Node::isRoot()
bool CompressedVectorNode::isRoot()                             {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node CompressedVectorNode::parent()                             {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring CompressedVectorNode::pathName()                        {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring CompressedVectorNode::elementName()                       {return(impl_->elementName());}

/*================*/ /*!
\brief   ??? Get number of records in CompressedVector.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t CompressedVectorNode::childCount()                      {return(impl_->childCount());}

/*================*/ /*!
\brief   ??? Get the prototype element tree that describes the types in the record.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
Node CompressedVectorNode::prototype()                          {return(Node(impl_->getPrototype()));}

/*================*/ /*!
\brief   ???  Not yet implemented!!!
\param   [in] pathName ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool CompressedVectorNode::isDefined(const ustring& pathName)   {return(impl_->isDefined(pathName));}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void CompressedVectorNode::dump(int indent, std::ostream& os)        {impl_->dump(indent, os);}
#else
void CompressedVectorNode::dump(int indent, std::ostream& os)        {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
CompressedVectorNode::operator Node()
{
    /// Implicitly upcast from shared_ptr<CompressedVectorNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a CompressedVector handle.
\param   [in] n ??? The generic handle to a CompressedVector object.
\details ???  The handle n must be for a CompressedVector node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
CompressedVectorNode::CompressedVectorNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<CompressedVectorNodeImpl>
    shared_ptr<CompressedVectorNodeImpl> ni(dynamic_pointer_cast<CompressedVectorNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
CompressedVectorNode::CompressedVectorNode(shared_ptr<CompressedVectorNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

/*================*/ /*!
\brief   ???  Create a writer object for writing blocks of data to CompressedVector.
\param   [in] sbufs ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
CompressedVectorWriter CompressedVectorNode::writer(std::vector<SourceDestBuffer>& sbufs)
{
    return(CompressedVectorWriter(impl_->writer(sbufs)));
}

/*================*/ /*!
\brief   ??? Create a reader object for reading blocks of data from a CompressedVector.
\param   [in] dbufs ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
CompressedVectorReader CompressedVectorNode::reader(std::vector<SourceDestBuffer>& dbufs)
{
    return(CompressedVectorReader(impl_->reader(dbufs)));
}

//=====================================================================================
/*! \class e57::IntegerNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     Node ???
*/

/*================*/ /*!
\brief   ??? Create an element for storing a integer value.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] value ???
\param   [in] minimum ???
\param   [in] maximum ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
IntegerNode::IntegerNode(ImageFile imf, int64_t value, int64_t  minimum, int64_t  maximum)
: impl_(new IntegerNodeImpl(imf.impl(), value, minimum, maximum))
{}

//! \copydoc Node::type()
NodeType IntegerNode::type()        {return(impl_->type());}

//! \copydoc Node::isRoot()
bool IntegerNode::isRoot()          {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node IntegerNode::parent()          {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring IntegerNode::pathName()     {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring IntegerNode::elementName()    {return(impl_->elementName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t IntegerNode::value()        {return(impl_->value());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t IntegerNode::minimum()      {return(impl_->minimum());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t IntegerNode::maximum()      {return(impl_->maximum());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void IntegerNode::dump(int indent, std::ostream& os) {impl_->dump(indent, os);}
#else
void IntegerNode::dump(int indent, std::ostream& os) {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
IntegerNode::operator Node()
{
    /// Upcast from shared_ptr<IntegerNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a Integer handle.
\param   [in] n ??? The generic handle to a Integer object.
\details ???  The handle n must be for a Integer node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
IntegerNode::IntegerNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<IntegerNodeImpl>
    shared_ptr<IntegerNodeImpl> ni(dynamic_pointer_cast<IntegerNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
IntegerNode::IntegerNode(shared_ptr<IntegerNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::ScaledIntegerNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     Node ???
*/

/*================*/ /*!
\brief   ??? Create an element for storing a fixed point numeric representation.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] value ???
\param   [in] minimum ???
\param   [in] maximum ???
\param   [in] scale ???
\param   [in] offset ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ScaledIntegerNode::ScaledIntegerNode(ImageFile imf, int64_t  value, int64_t  minimum, int64_t  maximum, double scale, double offset)
: impl_(new ScaledIntegerNodeImpl(imf.impl(), static_cast<uint64_t>(value), minimum, maximum, scale, offset))
{}

//! \copydoc Node::type()
NodeType ScaledIntegerNode::type()      {return(impl_->type());}

//! \copydoc Node::isRoot()
bool ScaledIntegerNode::isRoot()        {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node ScaledIntegerNode::parent()        {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring ScaledIntegerNode::pathName()   {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring ScaledIntegerNode::elementName()  {return(impl_->elementName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t ScaledIntegerNode::rawValue()   {return(impl_->rawValue());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double  ScaledIntegerNode::scaledValue(){return(impl_->scaledValue());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t ScaledIntegerNode::minimum()    {return(impl_->minimum());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t ScaledIntegerNode::maximum()    {return(impl_->maximum());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double  ScaledIntegerNode::scale()      {return(impl_->scale());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double  ScaledIntegerNode::offset()     {return(impl_->offset());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void ScaledIntegerNode::dump(int indent, std::ostream& os)   {impl_->dump(indent, os);}
#else
void ScaledIntegerNode::dump(int indent, std::ostream& os)   {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ScaledIntegerNode::operator Node()
{
    /// Upcast from shared_ptr<ScaledIntegerNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to an ScaledInteger handle.
\param   [in] n ??? The generic handle to a ScaledInteger object.
\details ???  The handle n must be for a ScaledInteger node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ScaledIntegerNode::ScaledIntegerNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<ScaledIntegerNodeImpl>
    shared_ptr<ScaledIntegerNodeImpl> ni(dynamic_pointer_cast<ScaledIntegerNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
ScaledIntegerNode::ScaledIntegerNode(shared_ptr<ScaledIntegerNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::FloatNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     Node ???
*/

/*================*/ /*!
\brief   ??? Create an element for storing an IEEE compatible floating point number.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] value ???
\param   [in] precision ???
\param   [in] minimum ???
\param   [in] maximum ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
FloatNode::FloatNode(ImageFile imf, float value, FloatPrecision precision, double minimum, double maximum)
: impl_(new FloatNodeImpl(imf.impl(), value, precision, minimum, maximum))
{}

/*================*/ /*!
\brief   ???
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] value ???
\param   [in] precision ???
\param   [in] minimum ???
\param   [in] maximum ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
FloatNode::FloatNode(ImageFile imf, double value, FloatPrecision precision, double minimum, double maximum)
: impl_(new FloatNodeImpl(imf.impl(), value, precision, minimum, maximum))
{}

//! \copydoc Node::type()
NodeType FloatNode::type()              {return(impl_->type());}

//! \copydoc Node::isRoot()
bool FloatNode::isRoot()                {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node FloatNode::parent()                {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring FloatNode::pathName()           {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring FloatNode::elementName()          {return(impl_->elementName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double FloatNode::value()               {return(impl_->value());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
FloatPrecision FloatNode::precision()   {return(impl_->precision());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double FloatNode::minimum()   {return(impl_->minimum());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
double FloatNode::maximum()   {return(impl_->maximum());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void FloatNode::dump(int indent, std::ostream& os)   {impl_->dump(indent, os);}
#else
void FloatNode::dump(int indent, std::ostream& os)   {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
FloatNode::operator Node()
{
    /// Upcast from shared_ptr<FloatNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a Float handle.
\param   [in] n ??? The generic handle to a Float object.
\details ???  The handle n must be for a Float node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
FloatNode::FloatNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<FloatNodeImpl>
    shared_ptr<FloatNodeImpl> ni(dynamic_pointer_cast<FloatNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
FloatNode::FloatNode(shared_ptr<FloatNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::StringNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     Node ???
*/

/*================*/ /*!
\brief   ??? Create an element for storing a Unicode string.
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] value ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StringNode::StringNode(ImageFile imf, ustring value)
: impl_(new StringNodeImpl(imf.impl(), value))
{}

//! \copydoc Node::type()
NodeType StringNode::type()     {return(impl_->type());}

//! \copydoc Node::isRoot()
bool StringNode::isRoot()       {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node StringNode::parent()       {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring StringNode::pathName()  {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring StringNode::elementName() {return(impl_->elementName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ustring StringNode::value()     {return(impl_->value());}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void StringNode::dump(int indent, std::ostream& os)  {impl_->dump(indent, os);}
#else
void StringNode::dump(int indent, std::ostream& os)  {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StringNode::operator Node()
{
    /// Upcast from shared_ptr<StringNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a String handle.
\param   [in] n ??? The generic handle to a String object.
\details ???  The handle n must be for a String node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StringNode::StringNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<StringNodeImpl>
    shared_ptr<StringNodeImpl> ni(dynamic_pointer_cast<StringNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
StringNode::StringNode(shared_ptr<StringNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::BlobNode
\brief   some doc???
\details some more doc???
\invariant ???
\see     Node ???
*/

/*================*/ /*!
\brief   ??? Create an element for storing a block of bytes with an specified format.
\brief   ???
\param   [in] imf ??? the ImageFile where the new node will eventually be stored.
\param   [in] byteCount ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
BlobNode::BlobNode(ImageFile imf, uint64_t byteCount)
: impl_(new BlobNodeImpl(imf.impl(), byteCount))
{}

//! \copydoc Node::type()
NodeType BlobNode::type()       {return(impl_->type());}

//! \copydoc Node::isRoot()
bool BlobNode::isRoot()         {return(impl_->isRoot());}

//! \copydoc Node::parent()
Node BlobNode::parent()         {return(Node(impl_->parent()));}

//! \copydoc Node::pathName()
ustring BlobNode::pathName()    {return(impl_->pathName());}

//! \copydoc Node::elementName()
ustring BlobNode::elementName()   {return(impl_->elementName());}

/*================*/ /*!
\brief   ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int64_t BlobNode::byteCount()   {return(impl_->byteCount());}

/*================*/ /*!
\brief   ???
\param   [in] buf ???
\param   [in] start ???
\param   [in] count ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void BlobNode::read(uint8_t* buf, uint64_t start, size_t count)
{
    impl_->read(buf, start, count);
}

/*================*/ /*!
\brief   ???
\param   [out] buf ???
\param   [in] start ???
\param   [in] count ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void BlobNode::write(uint8_t* buf, uint64_t start, size_t count)
{
    impl_->write(buf, start, count);
}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void BlobNode::dump(int indent, std::ostream& os)    {impl_->dump(indent, os);}
#else
void BlobNode::dump(int indent, std::ostream& os)    {}
#endif

/*================*/ /*!
\brief   Get a generic Node handle for this object.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
BlobNode::operator Node()
{
    /// Upcast from shared_ptr<StringNodeImpl> to shared_ptr<NodeImpl> and construct a Node object
    return(Node(impl_));
}

/*================*/ /*!
\brief   Convert from generic Node handle to a Blob handle.
\param   [in] n ??? The generic handle to a Blob object.
\details ???  The handle n must be for a Blob node, otherwise an exception is thrown.
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
BlobNode::BlobNode(Node& n)
{
    /// Downcast from shared_ptr<NodeImpl> to shared_ptr<BlobNodeImpl>
    shared_ptr<BlobNodeImpl> ni(dynamic_pointer_cast<BlobNodeImpl>(n.impl()));
    if (!ni)
        throw E57_EXCEPTION2(E57_ERROR_BAD_NODE_TYPECAST, "nodeType=" + toString(n.type()));

    /// Set our shared_ptr to the downcast shared_ptr
    impl_ = ni;
}

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
BlobNode::BlobNode(ImageFile imf, uint64_t fileOffset, uint64_t length)
: impl_(new BlobNodeImpl(imf.impl(), fileOffset, length))
{}

BlobNode::BlobNode(shared_ptr<BlobNodeImpl> ni)
: impl_(ni)
{}
//! \endcond

//=====================================================================================
/*! \class e57::ImageFile
\brief   some doc???
\details some more doc???
\invariant ???
\see     ???
*/

/*================*/ /*!
\brief   ??? Open an image file for reading/writing 3D data.
\param   [in] fname ???
\param   [in] mode ???
\param   [in] configuration ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ImageFile::ImageFile(const ustring& fname, const ustring& mode, const ustring& configuration)
: impl_(new ImageFileImpl())
{
    /// Do second phase of construction, now that ImageFile object is complete.
    impl_->construct2(fname, mode, configuration);
}

/*================*/ /*!
\brief   ??? Get the pre-established root node Structure of the E57 file.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
StructureNode   ImageFile::root()           {return(StructureNode(impl_->root()));}

/*================*/ /*!
\brief   ??? End operations on the E57 format file.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void            ImageFile::close()          {impl_->close();}

/*================*/ /*!
\brief   ??? End operations and delete a partially written E57 format file.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void            ImageFile::cancel()         {impl_->cancel();}

/*================*/ /*!
\brief   ??? Declare the use of an extension in a file being written.
\param   [in] prefix ???
\param   [in] uri ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void    ImageFile::extensionsAdd(const ustring& prefix, const ustring& uri)     {return(impl_->extensionsAdd(prefix, uri));}

/*================*/ /*!
\brief   ??? Get URI associated with an extension prefix
\param   [in] prefix ???
\param   [out] uri ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool    ImageFile::extensionsLookupPrefix(const ustring& prefix, ustring& uri)  {return(impl_->extensionsLookupPrefix(prefix, uri));}

/*================*/ /*!
\brief   ??? Get extension prefix associated with a URI.
\param   [in] uri ???
\param   [out] prefix ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
bool    ImageFile::extensionsLookupUri(const ustring& uri, ustring& prefix)     {return(impl_->extensionsLookupUri(uri, prefix));}

/*================*/ /*!
\brief   ??? Get number of namespaces used in file.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int     ImageFile::extensionsCount()                                            {return(impl_->extensionsCount());}

/*================*/ /*!
\brief   ??? Get extension prefixes declared in file by index.
\param   [in] index ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ustring ImageFile::extensionsPrefix(int index)                                  {return(impl_->extensionsPrefix(index));}

/*================*/ /*!
\brief   ??? Get extension URIs declared in file by index.
\param   [in] index ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ustring ImageFile::extensionsUri(int index)                                     {return(impl_->extensionsUri(index));}

/*================*/ /*!
\brief   ??? Test whether an element name uses any extension prefix.
\param   [in] elementName???
\details ???
\pre     ???
\post    ??? 
\return  true if elementName is a well formed and has an extension prefix.
\throw   ???
\see     ??? 
*/ //================
bool ImageFile::elementNameIsExtended(const ustring& elementName)
{
    return(impl_->elementNameIsExtended(elementName));
}

/*================*/ /*!
\brief   ??? Test whether an prospective element name has correct form. !!!
\param   [in] elementName???
\param   [in] allowNumber???
\details ???
\pre     ???
\post    ??? 
\return  true if elementName is well formed, else false.
\throw   ???
\see     ??? 
*/ //================
bool ImageFile::elementNameIsWellFormed(const ustring& elementName, bool allowNumber)
{
    return(impl_->elementNameIsWellFormed(elementName, allowNumber));
}

/*================*/ /*!
\brief   ??? Parse element name into prefix and localPart substrings.
\param   [in] elementName ???
\param   [out] prefix ???
\param   [out] localPart ???
\details ???
\pre     ???
\post    ??? 
\throw   ???
\see     ??? 
*/ //================
void ImageFile::elementNameParse(const ustring& elementName, ustring& prefix, ustring& localPart)
{
    return(impl_->elementNameParse(elementName, prefix, localPart));
}

//! \copydoc Node::dump()
#ifdef E57_DEBUG
void ImageFile::dump(int indent, std::ostream& os)   {impl_->dump(indent, os);}
#else
void ImageFile::dump(int indent, std::ostream& os)   {}
#endif

//=====================================================================================
/*! \class e57::E57Exception
\brief   some doc???
\details some more doc???
\invariant ???
\see     ???
*/

//! \cond documentNonPublic   The following isn't part of the API, and isn't documented.
E57Exception::E57Exception(ErrorCode ecode, ustring context, char* srcFileName, int srcLineNumber, char* srcFunctionName)
: errorCode_(ecode),
  context_(context),
  sourceFileName_(srcFileName),
  sourceFunctionName_(srcFunctionName),
  sourceLineNumber_(srcLineNumber)
{
}
//! \endcond

/*================*/ /*!
\brief   ??? Print error information on a given output stream.
\param   [in] reportingFileName ???
\param   [in] reportingLineNumber???
\param   [in] reportingFunctionName ???
\param   [in] os ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void E57Exception::report(char* reportingFileName, int reportingLineNumber, char* reportingFunctionName, std::ostream& os)
{
    os << "**** Got an e57 exception: " << E57Utilities().errorCodeToString(errorCode()) << endl;
#ifdef E57_DEBUG
    os << "  Debug info: " << endl;
    os << "    context: "             << context_ << endl;
    os << "    sourceFunctionName: "   << sourceFunctionName_ << endl;
    if (reportingFunctionName != NULL)
        os << "    reportingFunctionName: "   << reportingFunctionName << endl;


    /*** Add a line in error message that a smart editor (gnu emacs) can interpret as a link to the source code: */
    os << sourceFileName_ << "(" << sourceLineNumber_ << ") : error C" << errorCode_ << ":  <--- occurred on" << endl;
    if (reportingFileName != NULL)
        os << reportingFileName << "(" << reportingLineNumber << ") : error C0:  <--- reported on" << endl;
#endif
}

/*================*/ /*!
\brief   ??? Get numeric error code associated with the exception.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ErrorCode E57Exception::errorCode()
{
    return(errorCode_);
}

/*================*/ /*!
\brief   ??? Get string that describes context of exception.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
ustring E57Exception::context()
{
    return(context_);
}

/*================*/ /*!
\brief   ??? Get string description of exception.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
const char* E57Exception::what()
{
    //??? should return errorString?
    return("E57 exception");
}

/*================*/ /*!
\brief   ??? Get name of source file where exception occurred, for debugging.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
char* E57Exception::sourceFileName()
{
    return(sourceFileName_);
}

/*================*/ /*!
\brief   ??? Get name of function where exception occurred, for debugging.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
char* E57Exception::sourceFunctionName()
{
    return(sourceFunctionName_);
}

/*================*/ /*!
\brief   ??? Get line number in source file where exception occurred, for debugging.
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
int E57Exception::sourceLineNumber()
{
    return(sourceLineNumber_);
}


//=====================================================================================
/*! \class e57::E57Utilities
\brief   Utility functions not associated with any object
\details ??? 
*/

/*================*/ /*!
\fn      ??? e57::E57Utilities::E57Utilities(const ustring &)
\brief   ??? 
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================


/*================*/ /*!
\brief   Get latest version of ASTM standard supported, and library id string.
\param   [out] astmMajor ???
\param   [out] astmMinor ???
\param   [out] libraryId ???
\details ???
\return  English ustring describing error.
\throw   no E57Exception
\see     ??? 
*/ //================
void E57Utilities::getVersions(int& astmMajor, int& astmMinor, ustring& libraryId)
{
    astmMajor = E57_VERSION_MAJOR;
    astmMinor = E57_VERSION_MINOR;
    libraryId = E57_LIBRARY_ID;
}

/*================*/ /*!
\brief   Get short string description of an E57 ErrorCode.
\param   [in] ecode ???
\details ???
\return  English ustring describing error.
\throw   no E57Exception
\see     ??? 
*/ //================
ustring E57Utilities::errorCodeToString(ErrorCode ecode)
{
    switch (ecode) {
        case E57_SUCCESS:
            return("operation was successful (E57_SUCCESS)");
        case E57_ERROR_BAD_CV_HEADER:
            return("a CompressedVector binary header was bad (E57_ERROR_BAD_CV_HEADER)");
        case E57_ERROR_BAD_CV_PACKET:
            return("a CompressedVector binary packet was bad (E57_ERROR_BAD_CV_PACKET)");
        case E57_ERROR_CHILD_INDEX_OUT_OF_BOUNDS:
            return("a numerical index identifying a child was out of bounds (E57_ERROR_CHILD_INDEX_OUT_OF_BOUNDS)");
        case E57_ERROR_SET_TWICE:
            return("attempted to set an existing child element to a new value (E57_ERROR_SET_TWICE)");
        case E57_ERROR_HOMOGENEOUS_VIOLATION:
            return("attempted to add an E57 Element that would have made the children of a homogenous Vector have different types (E57_ERROR_HOMOGENEOUS_VIOLATION)");
        case E57_ERROR_VALUE_NOT_REPRESENTABLE:
            return("a value could not be represented in the requested type (E57_ERROR_VALUE_NOT_REPRESENTABLE)");
        case E57_ERROR_SCALED_VALUE_NOT_REPRESENTABLE:
            return("after scaling the result could not be represented in the requested type (E57_ERROR_SCALED_VALUE_NOT_REPRESENTABLE)");
        case E57_ERROR_REAL64_TOO_LARGE:
            return("a 64 bit IEEE float was too large to store in a 32 bit IEEE float (E57_ERROR_REAL64_TOO_LARGE)");
        case E57_ERROR_EXPECTING_NUMERIC:
            return("Expecting numeric representation in user's buffer, found ustring (E57_ERROR_EXPECTING_NUMERIC)");
        case E57_ERROR_EXPECTING_USTRING:
            return("Expecting string representation in user's buffer, found numeric (E57_ERROR_EXPECTING_USTRING)");
        case E57_ERROR_INTERNAL:
            return("An unrecoverable inconsistent internal state was detected (E57_ERROR_INTERNAL)");
        case E57_ERROR_BAD_XML_FORMAT:
            return("E57 primitive not encoded in XML correctly (E57_ERROR_BAD_XML_FORMAT)");
        case E57_ERROR_XML_PARSER:
            return("XML not well formed (E57_ERROR_XML_PARSER)");
        case E57_ERROR_BAD_API_ARGUMENT:
            return("bad API argument provided by user (E57_ERROR_BAD_API_ARGUMENT)");
        case E57_ERROR_FILE_IS_READ_ONLY:
            return("can't modify read only file (E57_ERROR_FILE_IS_READ_ONLY)");
        case E57_ERROR_CHECKSUM_MISMATCH:
            return("checksum mismatch, file is corrupted (E57_ERROR_CHECKSUM_MISMATCH)");
        case E57_ERROR_OPEN_FAILED:
            return("open() failed (E57_ERROR_OPEN_FAILED)");
        case E57_ERROR_CLOSE_FAILED:
            return("close() failed (E57_ERROR_CLOSE_FAILED)");
        case E57_ERROR_READ_FAILED:
            return("read() failed (E57_ERROR_READ_FAILED)");
        case E57_ERROR_WRITE_FAILED:
            return("write() failed (E57_ERROR_WRITE_FAILED)");
        case E57_ERROR_LSEEK_FAILED:
            return("lseek() failed (E57_ERROR_LSEEK_FAILED)");
        case E57_ERROR_PATH_UNDEFINED:
            return("E57 element path not defined (E57_ERROR_PATH_UNDEFINED)");
        case E57_ERROR_BAD_BUFFER:
            return("bad SourceDestBuffer (E57_ERROR_BAD_BUFFER)");
        case E57_ERROR_NO_BUFFER_FOR_ELEMENT:
            return("no buffer specified for an element in CompressedVector during write (E57_ERROR_NO_BUFFER_FOR_ELEMENT)");
        case E57_ERROR_BUFFER_SIZE_MISMATCH:
            return("SourceDestBuffers not all same size (E57_ERROR_BUFFER_SIZE_MISMATCH)");
        case E57_ERROR_BUFFER_DUPLICATE_PATHNAME:
            return("duplicate pathname in CompressedVector read/write (E57_ERROR_BUFFER_DUPLICATE_PATHNAME)");
        case E57_ERROR_BAD_FILE_SIGNATURE:
            return("file signature not ""ASTM-E57"" (E57_ERROR_BAD_FILE_SIGNATURE)");
        case E57_ERROR_UNKNOWN_FILE_VERSION:
            return("incompatible file version (E57_ERROR_UNKNOWN_FILE_VERSION)");
        case E57_ERROR_BAD_FILE_LENGTH:
            return("size in file header not same as actual (E57_ERROR_BAD_FILE_LENGTH)");
        case E57_ERROR_XML_PARSER_INIT:
            return("XML parser failed to initialize (E57_ERROR_XML_PARSER_INIT)");
        case E57_ERROR_DUPLICATE_NAMESPACE_PREFIX:
            return("namespace prefix already defined (E57_ERROR_DUPLICATE_NAMESPACE_PREFIX)");
        case E57_ERROR_DUPLICATE_NAMESPACE_URI:
            return("namespace URI already defined (E57_ERROR_DUPLICATE_NAMESPACE_URI)");
        case E57_ERROR_FILE_NOT_OPEN:
            return("file not open (E57_ERROR_FILE_NOT_OPEN)");
        case E57_ERROR_BUFFER_NOT_SPECIFIED:
            return("no buffers were specfied for read/write (E57_ERROR_BUFFER_NOT_SPECIFIED)");
        case E57_ERROR_BAD_PROTOTYPE:
            return("bad prototype in CompressedVector (E57_ERROR_BAD_PROTOTYPE)");
        case E57_ERROR_VALUE_OUT_OF_BOUNDS:
            return("element value out of min/max bounds (E57_ERROR_VALUE_OUT_OF_BOUNDS)");
        case E57_ERROR_CONVERSION_REQUIRED:
            return("conversion required to assign element value, but not requested (E57_ERROR_CONVERSION_REQUIRED)");
        case E57_ERROR_READ_MODE_REQUIRED:
            return("operation requires file opened for reading (E57_ERROR_READ_MODE_REQUIRED)");
        case E57_ERROR_BAD_ELEMENT_NAME:
            return("bad E57 element name (E57_ERROR_BAD_ELEMENT_NAME)");
        case E57_ERROR_BAD_PATH_NAME:
            return("bad E57 path name (E57_ERROR_BAD_PATH_NAME)");
        case E57_ERROR_BAD_NAME_CHAR:
            return("bad character in element name (E57_ERROR_BAD_NAME_CHAR)");
        case E57_ERROR_UNKNOWN_PREFIX:
            return("unknown namespace prefix (E57_ERROR_UNKNOWN_PREFIX)");
        case E57_ERROR_NOT_IMPLEMENTED:
            return("functionality not implemented (E57_ERROR_NOT_IMPLEMENTED)");
        case E57_ERROR_BAD_NODE_TYPECAST:
            return("bad typecast from Node to specific node type (E57_ERROR_BAD_NODE_TYPECAST)");
        case E57_ERROR_WRITER_NOT_OPEN:
            return("CompressedVector writer no longer open");
        case E57_ERROR_READER_NOT_OPEN:
            return("CompressedVector reader no longer open");
        default:
            return("<unknown ErrorCode>");
    }
}

/*================*/ /*!
\brief   ??? Get logical length of XML section of E57 file.
\param   [in] fname ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
uint64_t E57Utilities::rawXmlLength(const ustring& fname)
{
    /// Open file for reading.
    CheckedFile cf(fname, CheckedFile::readOnly);

    /// Get header from file (swabbed if neccesary)
    E57FileHeader header;
    ImageFileImpl::readFileHeader(&cf, header);

    return(header.xmlLogicalLength);
}

/*================*/ /*!
\brief   ??? Read portion of XML section of E57 file.
\param   [in] fname ???
\param   [out] buf ???
\param   [in] logicalStart ???
\param   [in] byteCount ???
\details ???
\pre     ???
\post    ??? 
\return  ??? 
\throw   ???
\see     ??? 
*/ //================
void E57Utilities::rawXmlRead(const ustring& fname, uint8_t* buf, uint64_t logicalStart, size_t byteCount)
{
    /// Open file for reading.
    CheckedFile cf(fname, CheckedFile::readOnly);

    /// Get header from file (swabbed if neccesary)
    E57FileHeader header;
    ImageFileImpl::readFileHeader(&cf, header);

    /// Check start and byteCount ok
    if (logicalStart + byteCount > header.xmlLogicalLength) {
        throw E57_EXCEPTION2(E57_ERROR_BAD_API_ARGUMENT,
                              "logicalStart=" + toString(logicalStart)
                            + " byteCount=" + toString(byteCount)
                            + " headerLength=" + toString(header.xmlLogicalLength));
    }
    
    /// Seek to logical position and read buffer
    cf.seek(cf.physicalToLogical(header.xmlPhysicalOffset) + logicalStart, CheckedFile::logical);
    cf.read(reinterpret_cast<char*>(buf), byteCount);
}
